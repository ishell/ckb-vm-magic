# 附录 H 端到端案例：secp256k1 验签在 ckb-vm 中的执行解剖

## H.1 目的

本附录给出“从输入到退出码”的一条完整案例线：

- 输入：包含签名与消息摘要的验证请求
- 过程：ELF 装载 -> 指令执行 -> 密码学热点路径
- 输出：返回成功/失败码与可计费成本

目标不是讲数学细节，而是把“工程执行路径”讲透。

## H.2 场景设定

假设合约完成一次标准验签，流程可抽象为：

1. 从参数读取签名、公钥、消息摘要
2. 执行曲线点运算与标量运算
3. 比较校验结果
4. 通过 `ecall` 退出并返回状态

## H.3 运行阶段分解

### H.3.1 装载阶段

- `parse_elf` 提取段信息和入口
- `load_binary_inner` 按 action 写页与权限
- `initialize_stack` 写入参数和 ABI 布局

### H.3.2 执行阶段

主循环反复执行：

- decode（含缓存与可能的 MOP 融合）
- cycles 累加
- execute（可能走 trace/threaded path）

### H.3.3 退出阶段

- 验签成功或失败写入 `a0`
- `A7=93` 调用 `ecall` 退出
- `exit_code` 返回给宿主

## H.4 热点路径画像（工程视角）

在典型实现中，热点会集中在：

- 大整数乘法/约简链
- 位操作与条件选择
- 少量内存加载与状态搬运

这解释了为何以下机制重要：

- M/MOP：降低大整数链开销
- B 扩展：降低位操作拼装开销
- Trace：降低循环体解释器噪声

## H.5 成本剖析模板

建议记录以下指标：

- `total_cycles`
- `top_opcodes`
- `mop_hit_ratio`
- `trace_hit_ratio`
- `syscall_count`

结合输入规模变化（批量验签 N）观测曲线形态，才能判断优化是否真实有效。

## H.6 风险点清单

1. 跨后端语义漂移：Rust/ASM 路径结果不一致
2. 计费偏差：热点路径被低估导致 DoS 面
3. 侧信道风险：数据相关分支或访存模式
4. 版本兼容风险：语义修复影响旧合约

## H.7 审计流程示例

- 第一步：固定测试向量，跑 Rust 与 ASM 双后端
- 第二步：比较寄存器摘要与内存摘要
- 第三步：比较 cycles 与错误码一致性
- 第四步：对热点函数做恒时风险检查

## H.8 与主文的映射关系

- 执行主线：第 2、4 章
- 权限与装载：第 3 章
- 密码学指令映射：第 10 章
- 风险与治理：第 11 章

## H.9 一针见血结论

端到端案例的价值在于把“抽象架构论点”落成“可复现实验事实”；没有案例，优化与安全都容易停留在口号层。

