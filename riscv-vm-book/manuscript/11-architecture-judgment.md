# 第 11 章 架构总评：优势、代价与下一步

## 11.1 核心问题

这套架构真正赢在哪里？真实代价又是什么？

## 11.2 图 11-1：收益与成本矩阵

```text
收益侧:                       成本侧:
- 可验证执行                 - 双后端一致性维护
- 清晰权限边界               - cycles 模型校准压力
- 可恢复执行                 - syscall 生态集成复杂
- 渐进式性能优化             - 密码学侧信道防护额外投入
```

## 11.3 优势判断

1. 执行边界清晰：装载、执行、syscall、快照职责分离。
2. 协议兼容策略明确：`VERSION0/1/2` 保留历史语义。
3. 优化路径可审计：trace/MOP/ASM 都可被代码定位和验证。
4. 权限模型扎实：W^X 与冻结页机制降低注入面。

## 11.4 风险判断

1. 双执行后端一旦测试覆盖不足，存在分歧风险。
2. `estimate_cycles` 需要持续与真实负载校准，否则会出现计费失真。
3. 宿主扩展能力越多，边界管理复杂度越高。
4. 当前确定性模型不自动提供恒时安全，需要密码学专项治理。

## 11.5 案例：最容易被误判的优化方向

常见误判是“先追求更激进 JIT，再补安全验证”。在共识场景里应反过来：

- 先证明边界可控
- 再增量引入优化

否则短期提速可能换来长期分叉风险。

## 11.6 术语表（本章）

- `Differential Testing`：差分测试，比较多后端结果一致性。
- `Semantic Drift`：语义漂移，指实现与规范逐渐偏离。
- `Execution Governance`：执行层治理，指升级与兼容策略体系。

## 11.7 一针见血结论

`ckb-vm` 的护城河不是“某项黑科技优化”，而是把共识执行做成了可治理的系统工程。

## 11.8 反例分析：没有升级护栏的“快速演进”

反例场景：频繁升级执行层却缺少版本兼容和发布门禁：

- 历史交易重放结果漂移，破坏链上可验证性。
- 运维侧难以判断升级影响半径。

教训：执行层升级必须以可回滚、可验证、可量化影响为前提。

## 11.9 架构评审清单（出版版）

- [ ] 是否有版本分层与历史语义保留策略。
- [ ] 发布前是否进行跨后端、跨平台差分验证。
- [ ] 是否有 cycles 模型与经济参数的联动评审。
- [ ] 是否具备回滚预案与兼容性公告模板。

## 11.10 参考实现清单（代码锚点）

- `src/machine/mod.rs`: `VERSION0/1/2`, `run_with_decoder`
- `src/machine/asm/mod.rs`: 汇编后端返回码与慢路径回退
- `src/memory/wxorx.rs`: W^X 权限模型
- `src/cost_model.rs`: 计费模型参数化

## 11.11 术语索引交叉（参见附录 B 与附录 D）

- `Differential Testing`
- `Semantic Drift`
- `Execution Governance`
- `Cycle Budget`


## 11.12 审稿人问题清单（出版评审）

1. 优势与代价是否对称呈现，避免单边叙事？
2. 是否将“版本兼容”作为首要治理约束？
3. 是否提供了可执行的发布门禁逻辑？
4. 是否强调了差分测试与回滚预案的必要性？
5. 章节结论是否能直接转化为架构决策标准？
6. 本章是否与附录 E 的出版规范形成闭环？
