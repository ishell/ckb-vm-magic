# 图 3-1 长文：ELF 到页动作的转换，为什么这是 VM 的第一道安全防线

## 摘要

很多工程把“装载器”当成输入解析器，但在区块链 VM 里，装载器实际上是“安全语义编译器”：

- 把外部 ELF 翻译成受控内存状态
- 把权限策略固化为页级规则
- 把非法输入转换为确定错误

## 1. 从二进制文件到 `ProgramMetadata`

`parse_elf` 的关键产物不是“解析成功”，而是 `ProgramMetadata`：

- `actions[]`：每个页动作的地址、大小、权限、数据切片、偏移
- `entry`：入口地址

这意味着“装载行为”本身可以被缓存、复核、重放。

## 2. 权限映射不是建议，是硬拒绝

`convert_flags` 的两个强拒绝非常关键：

- 不可读段直接拒绝
- 可写且可执行段直接拒绝

随后 `WXorXMemory` 在运行期继续执行页权限检查，实现“装载期 + 执行期”双保险。

## 3. 为什么要做双阶段权限控制

只在装载期做权限判断不够，因为运行期仍可能发生：

- 越权写入
- 边界跨页误写
- 历史页状态污染

只在运行期检查也不够，因为非法映像会在更早阶段放大风险。

两者组合才是安全闭环。

## 4. 边界问题的真实难点

装载器最容易出错的不是主路径，而是边界组合：

- `offset + filesz` 越界
- `size/page align` 不一致
- `offset_from_addr` 与页内填充冲突

`ckb-vm` 在 `parse_elf` 和 `WXorXMemory::init_pages` 对这些条件有显式拒绝路径，这是工程成熟度的重要信号。

## 5. 栈初始化为什么也属于装载安全

在共识系统里，栈布局不是 ABI 小事。`initialize_stack` 涉及：

- 对齐策略
- `argc/argv` 结构
- 版本兼容行为

任何栈初始化差异都可能在合约入口阶段放大成跨节点行为差异。

## 6. 审计模型：把装载器当作“状态转换器”

推荐用“三段式审计”：

1. 输入合法性：ELF 字段与切片边界
2. 转换正确性：action 序列是否符合权限规则
3. 结果可验证：页标志与入口状态是否可重算

这比“看代码是否优雅”更有效。

## 7. 读者实验建议

做一个最小实验：

- 构造一个 `W+X` 段 ELF
- 观察装载阶段错误是否稳定
- 在 Rust 与 ASM 路径对拍错误码

这个实验能快速验证“装载防线”是否真实有效。

## 8. 与主文映射

- 对应章节：`第 3 章`
- 关键代码：`src/elf.rs`, `src/memory/wxorx.rs`, `src/machine/mod.rs`
- 关联附录：`附录 E`（规范）、`附录 G`（改稿清单）

## 9. 一针见血结论

ELF 装载器不是“把程序读进来”，而是把不可信输入约束为可信执行起点。

