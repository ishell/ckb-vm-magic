# 图 1-1 长文：共识 VM 约束层级不是示意图，而是设计宪法

## 摘要

“协议约束 -> 经济约束 -> 工程约束 -> 执行优化”这四层关系，不是讲解时的教学美化，而是区块链 VM 的实际设计顺序。

只要顺序倒置（例如先追求峰值性能，再补确定性），系统就会在边界输入、计费公平和升级兼容上出现不可控风险。

## 1. 原图重述

图 1-1 的四层结构是：

```text
协议约束(可验证/可回放)
经济约束(可计费/抗 DoS)
工程约束(可维护/可审计)
执行优化(Trace/ASM/MOP)
```

注意：这是“约束优先级”，不是“模块分层图”。

## 2. 第一层：协议约束（最上层）

协议层关心的是“全网一致”，不是单机正确。它要求 VM 满足：

- 同输入下，状态迁移一致
- 错误触发条件一致
- 恢复与重放结果一致

在 `ckb-vm` 中，这种要求落在可定位代码上：

- 结构化错误：`src/error.rs`
- 版本门控：`src/machine/mod.rs` `VERSION0/1/2`
- 执行主循环：`run_with_decoder`

任何优化若破坏上述一致性，都属于协议级故障。

## 3. 第二层：经济约束（可定价）

共识系统的 DoS 防线不是“节点跑更快”，而是“攻击者付得起吗”。

`SupportMachine::add_cycles` 的意义在于把执行与预算绑定：

- 超上限：`CyclesExceeded`
- 溢出：`CyclesOverflow`

这使资源消耗从实现细节变成协议可观察量。没有这一层，性能优化会被攻击者反向利用。

## 4. 第三层：工程约束（可维护）

即使语义正确、计费正确，如果工程上不可审计，系统仍会在中长期失控。常见症状：

- 边界语义散落在多个后端
- 版本升级难以证明兼容
- 回归问题无法快速归因

`ckb-vm` 的有效做法是把关键边界集中在“少数可审阅接口”中：

- `Machine/CoreMachine/SupportMachine` trait 边界
- `Memory` 与 `WXorXMemory` 权限边界
- `Syscalls` 宿主注入边界

## 5. 第四层：执行优化（最后谈）

Trace、MOP、ASM 都重要，但它们只有在前三层稳定后才安全。

错误的做法是“先上快路径，再找语义解释”；正确做法是“先有语义锚点，再做快路径外包”。

这就是为什么 `ckb-vm` 保留 Rust 语义主线，并允许 ASM 在 `RET_SLOWPATH` 回退。

## 6. 反例推演：层级倒置会发生什么

### 场景 A：先优化后计费

- 结果：热点路径被低估，攻击交易成本下降
- 后果：出现经济性 DoS 窗口

### 场景 B：先优化后版本治理

- 结果：新老版本边界行为漂移
- 后果：历史交易重放不稳定

### 场景 C：先优化后审计收敛

- 结果：问题定位依赖“实现者记忆”
- 后果：线上故障恢复时间不可控

## 7. 从图到审计：最小检查表

1. 本改动是否影响错误码映射？
2. 本改动是否影响 cycles 累积或上限触发？
3. 本改动是否引入新的宿主隐式依赖？
4. 本改动是否跨版本保持可回放？

这四问可以直接作为 PR 门禁。

## 8. 与主文映射

- 对应章节：`第 1 章`
- 关键代码：`src/machine/mod.rs`, `src/error.rs`, `src/cost_model.rs`
- 关联附录：`附录 E`（出版规范）、`附录 F`（密码学 PR 审计模板）

## 9. 一针见血结论

图 1-1 的价值不在“解释清楚”，而在“强制设计顺序”：先守共识，再谈性能。

