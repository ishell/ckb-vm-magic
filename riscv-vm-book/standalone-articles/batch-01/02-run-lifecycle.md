# 图 2-1 长文：从 run 到 exit 的生命周期，为什么必须做成显式状态机

## 摘要

“run_with_memory -> load_program -> run -> exit_code”看起来是一条普通流程，但在共识 VM 中，它必须是可审计状态机：

- 每个状态可命名
- 每个转移可验证
- 每个失败可复现

否则线上问题无法做确定归因。

## 1. 原图再定义：从流程图到状态图

图 2-1 可重写为七态模型：

1. `Created`
2. `LoadedELF`
3. `StackReady`
4. `Running`
5. `Trapped`
6. `Exited`
7. `Errored`

其中 `Running <-> Trapped` 可循环，其余转移应单向、可解释。

## 2. 装载阶段为什么不能“顺手做掉”

`load_program` 在 `ckb-vm` 里被拆成：

- `load_elf`：映像写入和入口设置
- `initialize`：syscall/debugger 初始化 + 栈准备

这种拆分意义很大：

- 装载失败与执行失败语义可区分
- 栈 ABI 错误可单独归因
- 快照/恢复可插入明确节点

## 3. 运行循环的三道闸门

`run_with_decoder` 每轮至少检查：

1. `pause` 中断
2. `reset_signal` 缓存失效
3. `step` 的 decode/execute/cycles

这三道闸门把“可中断、可重置、可计费”变成主循环固有属性，而不是外围临时逻辑。

## 4. 失败语义为什么要结构化

如果运行失败只返回文本字符串，跨节点、跨后端就很难稳定比较。

`Error` 枚举的工程价值在于：

- 每类失败都有固定语义
- 可用于差分测试和发布门禁
- 可与版本兼容策略绑定

这也是“故障可治理”的前提。

## 5. `ecall` 的内核最小闭环

`Machine::ecall` 默认内建仅 `93`（退出），其余交外部 `Syscalls`。

这是非常关键的架构选择：

- 内核保留最小闭环能力
- 宿主能力显式注入
- 共识边界不被宿主细节污染

## 6. 实战示例：一次最小退出路径

可观测序列通常是：

- `A7 <- 93`
- `A0 <- exit_code`
- `ecall`
- `set_running(false)`
- `run()` 返回 `exit_code`

如果某后端在此路径上行为不同，差分测试应立即报警。

## 7. 审计与运维视角

### 审计要点

- 是否存在未命名的隐式状态转移？
- 是否存在异常路径跳过计费检查？
- 是否存在 reset 后缓存未失效风险？

### 运维要点

- 失败是否可由错误码直接归类？
- 快照恢复是否可定位到状态节点？

## 8. 与主文映射

- 对应章节：`第 2 章`
- 关键代码：`src/lib.rs`, `src/machine/mod.rs`
- 关联附录：`附录 D` 术语交叉索引

## 9. 一针见血结论

生命周期设计不是“流程顺手写出来”，而是共识系统的控制平面，必须显式、可检验、可回放。

