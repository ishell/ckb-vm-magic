# 图 8-1 长文：Rust + ASM 混合控制流，如何做到“快路径服从语义锚点”

## 摘要

图 8-1 的核心不是“有汇编就更快”，而是“如何让汇编加速不破坏语义主权”。`ckb-vm` 的关键做法是：

- ASM 负责高频执行
- Rust 负责状态机解释与错误语义
- 慢路径可回退到 Rust 保底

这是共识系统中非常务实的折中架构。

## 1. 原图重述：控制流分工

图 8-1 可表达为：

```text
ASM execute
  -> RET_* status
     -> Rust dispatcher
        -> ecall/ebreak/slowpath/error mapping
```

即“汇编执行 + Rust 控制平面”的二层结构。

## 2. 为什么不能纯汇编到底

纯汇编的风险不在性能，而在治理：

- 语义文档化成本高
- 差分定位成本高
- 新成员维护门槛高

在共识系统里，长期可维护性比短期峰值更关键。Rust 作为语义锚点，可以持续承接版本演进与审计。

## 3. `RET_SLOWPATH` 的战略价值

`RET_SLOWPATH` 并不是“性能不足时的临时补丁”，而是架构安全阀：

- 快路径未覆盖场景可回退
- 新语义可先在 Rust 落地
- 汇编后续按优先级补齐

这让系统具备“可增量优化、可持续正确”的演进能力。

## 4. 双后端一致性是主成本

混合架构最大成本是一致性维护，主要体现在：

- 新 opcode 要双实现
- 语义修复要双同步
- 边界行为要双验证

因此必须有常态化差分流水线，否则会积累“潜在分叉债务”。

## 5. 推荐差分矩阵

最小矩阵建议：

- 后端：Rust / ASM
- 输入：正常 / 边界 / 恶意
- 指标：exit_code / cycles / reg_digest / mem_digest

任何差异都应阻断合并并自动归档。

## 6. 发布策略建议

建议采用“语义先行”策略：

1. Rust 先落语义
2. 测试先证明等价
3. ASM 再做热点加速

若顺序反过来，往往会把优化问题升级成共识风险。

## 7. 审计清单

1. 新增 `RET_*` 是否有完整处理映射？
2. slowpath 回退是否覆盖未实现 opcode？
3. Rust/ASM 是否有同版本同输入差分报告？
4. 构建矩阵是否明确平台支持与禁用策略？

## 8. 与主文映射

- 对应章节：`第 8 章`
- 关键代码：`build.rs`, `src/machine/asm/mod.rs`, `src/machine/asm/traces.rs`
- 关联附录：`附录 C`（RISC-V 治理）、`附录 F`（审计模板）

## 9. 一针见血结论

混合架构的正确打开方式不是“把语义交给汇编”，而是“让汇编在 Rust 语义边界内加速”。

