# 图 5-1 长文：ecall 分发路径，如何把宿主能力关进最小边界

## 摘要

`ecall` 在区块链 VM 中不是“调用系统 API”的便捷入口，而是共识安全边界。图 5-1 的分发路径揭示了一个核心原则：

- 内核只保留最小可验证语义
- 宿主能力必须显式注入
- 无处理能力时必须稳定失败

这三点共同决定了 Trusted Computing Base（TCB）的大小。

## 1. 原图重述：从 guest 指令到宿主处理

图 5-1 可抽象为以下链路：

```text
guest ecall
  -> Machine::ecall
     -> if A7 == 93: exit
     -> else: iterate syscall modules
     -> if none handled: InvalidEcall
```

注意该路径有两个关键约束：

1. `A7=93` 是内核闭环语义（退出）
2. 其余能力全部外置到 `Syscalls` 模块

## 2. 为什么只内建 `exit(93)`

把退出能力内建有两个现实理由：

- VM 必须保证“可终止”语义自洽
- 退出码是执行结果的一部分，不能依赖外部模块存在

反过来，如果连退出都外包，系统会出现“没有 syscall 模块就无法稳定终止”的反常状态。

## 3. 插件式 syscall 的安全收益

`Syscalls` trait 的接口很小：`initialize` 与 `ecall`。这带来三类收益：

1. **审计收敛**：核心 VM 不必内置复杂宿主能力。
2. **部署灵活**：不同场景可挂不同能力集。
3. **失败可控**：未处理 syscall 返回 `InvalidEcall`，不是静默成功。

在共识系统里，“明确失败”比“隐式兼容”更安全。

## 4. ABI 视角：为什么 syscall 也要文档化

多数系统出问题不是算法错，而是 ABI 漂移：

- 输入寄存器约定改变
- 输出寄存器未定义
- 错误码含义模糊

建议每个 syscall 都有固定模板：

- 编号（A7）
- 入参寄存器/内存布局
- 出参寄存器
- 错误码
- cycles 影响

这在多团队协作时尤为关键。

## 5. 常见反模式

### 反模式 A：把网络/文件系统能力直接塞进 VM 核心

短期看“功能齐全”，长期会导致：

- TCB 膨胀
- 宿主差异污染共识语义
- 审计成本爆炸

### 反模式 B：未处理 syscall 返回默认成功

这会让“能力不存在”被误判为“执行成功”，是最危险的语义歧义之一。

### 反模式 C：宿主副作用不计费

若 syscall 消耗大量外部资源但不计入 cycles，会形成经济模型漏洞。

## 6. 审计清单（可直接挂 PR）

1. 新增 syscall 是否附完整 ABI 说明？
2. 未处理路径是否稳定返回 `InvalidEcall`？
3. 宿主副作用是否有计费或额度边界？
4. Rust/ASM 后端是否在该 syscall 上行为一致？
5. 禁用该模块后是否保持核心 VM 可运行（至少可退出）？

## 7. 与主文映射

- 对应章节：`第 5 章`
- 关键代码：`src/machine/mod.rs`, `src/syscalls/mod.rs`, `examples/ckb_vm_runner.rs`
- 关联附录：`附录 F`（密码学 PR 审计模板）

## 8. 一针见血结论

ecall 设计的关键不是“能做多少事”，而是“把宿主能力控制在多小、且仍可验证”。

