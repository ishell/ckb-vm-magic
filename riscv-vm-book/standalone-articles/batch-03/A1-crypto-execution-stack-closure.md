# 图 A-1 长文：密码学执行栈闭环，为什么必须从算法层写到计费层

## 摘要

图 A-1 不是知识图谱，而是执行闭环图：

- 算法层决定算子结构
- 算子层决定指令分布
- 指令层决定执行器行为
- 执行层决定计费现实

只优化其中一层，通常会把问题转移到另一层。

## 1. 原图重述

```text
算法层 -> 算子层 -> 指令层 -> 执行层 -> 计费层
```

这条链的核心是“闭环”：任何一层改动都应反馈到计费与安全评估。

## 2. 算法层与算子层

算法实现的选择会改变算子谱：

- 大整数实现方式影响乘加链密度
- 哈希轮函数实现方式影响位操作密度

如果团队不先做算子画像，就很容易做错优化优先级。

## 3. 指令层与执行层

算子映射到指令后，执行器的机制开始主导成本：

- decode cache 命中与否
- trace 稳定性
- MOP 融合命中率

这也是为什么“同一算法”在不同执行器策略下费用表现会差异明显。

## 4. 计费层不是收尾步骤

计费应参与设计早期，而非上线前补丁。理由：

- 计费参数会反向影响攻击面
- 计费错误会影响生态公平性

正确流程是“开发-测试-计费校准-发布”闭环，而不是线性流水。

## 5. 侧信道与确定性的并行治理

密码学执行栈还需并行关注：

- 功能确定性（共识）
- 恒时安全（隐私与密钥安全）

两者测试体系不同，不能互相替代。

## 6. 闭环化实践模板

每次密码学优化至少输出：

1. 算子画像报告
2. 指令分布报告
3. 执行命中报告（trace/MOP）
4. 计费偏差报告
5. 侧信道检查结论

这样优化才算“闭环完成”。

## 7. 与主文映射

- 对应附录：`附录 A`
- 关键代码：`src/cost_model.rs`, `src/decoder.rs`, `src/instructions/execute.rs`
- 关联附录：`附录 F`, `附录 H`, `附录 I`

## 8. 一针见血结论

密码学执行优化的成熟标志不是“跑分更高”，而是“从算法到计费的证据链闭合”。

