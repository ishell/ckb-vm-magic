<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 与 RISC-V：区块链虚拟机的工程必然性</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-5252cc92.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-076badc4.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 与 RISC-V：区块链虚拟机的工程必然性</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/nervosnetwork/ckb-vm" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="封面页"><a class="header" href="#封面页">封面页</a></h1>
<h2 id="rust-与-risc-v区块链虚拟机的工程必然性"><a class="header" href="#rust-与-risc-v区块链虚拟机的工程必然性">Rust 与 RISC-V：区块链虚拟机的工程必然性</a></h2>
<ul>
<li>副标题：从共识确定性到密码学执行路径的系统化分析</li>
<li>基础代码：<code>nervosnetwork/ckb-vm</code></li>
<li>文档形态：工程出版版（可审计、可复现、可演进）</li>
</ul>
<h3 id="核心主张"><a class="header" href="#核心主张">核心主张</a></h3>
<ol>
<li>区块链 VM 首先是共识机器，不是本地性能机器。</li>
<li>Rust 的关键价值是语义边界前移，不是语言流行度。</li>
<li>RISC-V 的关键价值是长期治理能力，不是短期跑分。</li>
</ol>
<h3 id="使用说明"><a class="header" href="#使用说明">使用说明</a></h3>
<ul>
<li>阅读主线：第 1-11 章</li>
<li>专题扩展：附录 A（密码学）与附录 C（RISC-V）</li>
<li>交叉检索：附录 B + 附录 D</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="版本页"><a class="header" href="#版本页">版本页</a></h1>
<h2 id="文档版本信息"><a class="header" href="#文档版本信息">文档版本信息</a></h2>
<ul>
<li>文档名称：Rust 与 RISC-V：区块链虚拟机的工程必然性</li>
<li>当前版本：v0.7.0</li>
<li>发布阶段：出版评审版（实验与教学增强）</li>
<li>发布日期：2026-02-08</li>
<li>语言：zh-CN</li>
</ul>
<h2 id="对应代码基线"><a class="header" href="#对应代码基线">对应代码基线</a></h2>
<ul>
<li>仓库：<code>https://github.com/nervosnetwork/ckb-vm</code></li>
<li>代码分析范围：<code>src/</code>、<code>examples/</code>、<code>definitions/</code> 相关实现</li>
<li>主题覆盖：执行主线、内存权限、syscall 边界、快照、Rust 语义、RISC-V 扩展</li>
</ul>
<h2 id="版本策略"><a class="header" href="#版本策略">版本策略</a></h2>
<ul>
<li><code>major</code>：结构性重写（章节体系调整）</li>
<li><code>minor</code>：新增专题附录、实验层或教学层</li>
<li><code>patch</code>：错别字、引用修复、术语澄清</li>
</ul>
<h2 id="维护策略"><a class="header" href="#维护策略">维护策略</a></h2>
<ul>
<li>每次内容变更应同步更新：
<ol>
<li>版本页</li>
<li>更新日志</li>
<li>审稿人摘要页</li>
<li>相关附录（术语索引、审计模板、图示长文、实验与教学）</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="更新日志"><a class="header" href="#更新日志">更新日志</a></h1>
<h2 id="v070---2026-02-08"><a class="header" href="#v070---2026-02-08">v0.7.0 - 2026-02-08</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>新增图示长文实验层（labs）：
<ul>
<li>通用准备</li>
<li>批次一实验手册</li>
<li>批次二实验手册</li>
<li>批次三实验手册</li>
</ul>
</li>
<li>新增教学层（teaching）：
<ul>
<li>课程地图</li>
<li>教学讲义</li>
<li>练习题</li>
<li>参考答案与评分建议</li>
</ul>
</li>
<li>mdBook 新增实验与教学导航入口。</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>项目总目录结构升级为“主文 + 图示长文 + 实验 + 教学 + 附录”。</li>
<li>导读页和 README 文档同步到新结构。</li>
</ul>
<h2 id="v060---2026-02-08"><a class="header" href="#v060---2026-02-08">v0.6.0 - 2026-02-08</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>图示拆解长文批次三（5 篇）并接入 mdBook：
<ul>
<li>图 9-1、10-1、11-1</li>
<li>图 A-1、C-1</li>
</ul>
</li>
<li>新增 <code>standalone-articles/batch-03/</code> 目录与批次说明。</li>
<li>mdBook 目录增加批次三长文入口。</li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li>图示长文路线图更新为“批次一/二/三已完成”。</li>
<li>导读、README、索引页同步到批次三状态。</li>
</ul>
<h2 id="v050---2026-02-08"><a class="header" href="#v050---2026-02-08">v0.5.0 - 2026-02-08</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>新增 mdBook 发布页体系：
<ul>
<li>封面页</li>
<li>版本页</li>
<li>更新日志页</li>
<li>审稿人变更摘要页</li>
</ul>
</li>
<li>11 个章节 wrapper 统一页眉页脚，形成一致出版展示。</li>
<li>新增附录 G（作者改稿检查清单）。</li>
<li>新增附录 F（密码学 PR 审计模板）并接入目录。</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>第 1-11 章新增“审稿人问题清单（出版评审）”。</li>
<li>顶层 README、manuscript README、mdBook README 全部同步到新结构。</li>
</ul>
<h2 id="v040---2026-02-08"><a class="header" href="#v040---2026-02-08">v0.4.0 - 2026-02-08</a></h2>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>主体第 1-11 章新增出版收口结构：
<ul>
<li>反例分析</li>
<li>架构评审清单</li>
<li>参考实现清单</li>
<li>术语交叉索引</li>
</ul>
</li>
<li>新增附录 C（RISC-V 专题扩展版）</li>
<li>新增附录 D（术语交叉索引）</li>
<li>新增附录 E（出版规范与合规矩阵）</li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li>术语总表升级为带锚点版本，支持章节交叉引用。</li>
<li>目录结构按“主线阅读 + 专题附录 + 审计辅助”重排。</li>
</ul>
<h2 id="v030---2026-02-08"><a class="header" href="#v030---2026-02-08">v0.3.0 - 2026-02-08</a></h2>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li>第 1-11 章完整稿（严肃专业版）</li>
<li>附录 A 密码学专题初版</li>
<li>mdBook 基础可读结构</li>
</ul>
<h2 id="v020---2026-02-08"><a class="header" href="#v020---2026-02-08">v0.2.0 - 2026-02-08</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li>分批扩展稿：执行主线、Rust/RISC-V 论证、架构评估</li>
</ul>
<h2 id="v010---2026-02-08"><a class="header" href="#v010---2026-02-08">v0.1.0 - 2026-02-08</a></h2>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>初始大纲与章节规划</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="审稿人变更摘要页"><a class="header" href="#审稿人变更摘要页">审稿人变更摘要页</a></h1>
<blockquote>
<p>版本范围：<code>v0.6.0</code> -&gt; <code>v0.7.0</code><br>评审目标：确认“图示长文 -&gt; 实验 -&gt; 教学”三层链路已闭环。</p>
</blockquote>
<h2 id="一这次改了什么按影响度排序"><a class="header" href="#一这次改了什么按影响度排序">一、这次改了什么（按影响度排序）</a></h2>
<ol>
<li>新增实验层：每个图示批次均有可复现实验手册。</li>
<li>新增教学层：课程地图、讲义、练习题、答案评分。</li>
<li>mdBook 索引升级：支持“阅读 + 实验 +授课”三种使用路径。</li>
<li>文档结构升级为五层：主文、图示长文、实验、教学、附录。</li>
</ol>
<h2 id="二审稿建议路径30-45-分钟快速审"><a class="header" href="#二审稿建议路径30-45-分钟快速审">二、审稿建议路径（30-45 分钟快速审）</a></h2>
<ul>
<li>第一步：查看 <code>实验总准备</code> 与 <code>实验手册-批次一/二/三</code>。</li>
<li>第二步：查看 <code>教学地图</code> 与 <code>教学讲义</code> 是否覆盖主文核心脉络。</li>
<li>第三步：抽查 2 个练习题与答案是否与主文结论一致。</li>
<li>第四步：确认实验命令与测试文件在仓库中可定位。</li>
</ul>
<h2 id="三重点审稿问题高优先级"><a class="header" href="#三重点审稿问题高优先级">三、重点审稿问题（高优先级）</a></h2>
<ol>
<li>实验步骤是否具备可复现性（命令、输入、预期）？</li>
<li>教学材料是否保持“证据优先”，避免口号化？</li>
<li>练习题是否覆盖语义、计费、治理三类能力？</li>
<li>答案评分标准是否可执行、可复核？</li>
</ol>
<h2 id="四签署建议"><a class="header" href="#四签署建议">四、签署建议</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 通过：可进入终版排版</li>
<li><input disabled="" type="checkbox"> 条件通过：需补充实验记录样本</li>
<li><input disabled="" type="checkbox"> 拒绝通过：实验或教学链路存在断点</li>
</ul>
<p>签署人：<br>日期：</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-与-risc-v区块链虚拟机的工程必然性-1"><a class="header" href="#rust-与-risc-v区块链虚拟机的工程必然性-1">Rust 与 RISC-V：区块链虚拟机的工程必然性</a></h1>
<p>本书基于 <code>ckb-vm</code> 源码，系统分析区块链 VM 的操作系统化设计，并回答两个核心问题：</p>
<ol>
<li>为什么共识执行层倾向选择 Rust？</li>
<li>为什么 RISC-V 能成为可治理的长期 ISA 方案？</li>
</ol>
<h2 id="结构说明"><a class="header" href="#结构说明">结构说明</a></h2>
<ul>
<li>发布页：封面、版本、更新日志、审稿人摘要</li>
<li>主体：第 1-11 章（出版版 + 深度扩展段）</li>
<li>图示拆解长文：将“图 X-1”扩展为独立文章（完成批次一/二/三）</li>
<li>实验手册：每批图示长文对应可复现实验</li>
<li>教学资料：讲义、练习题、参考答案</li>
<li>附录 A：密码学专题（工作负载映射、计费校准、发布门禁）</li>
<li>附录 F：密码学实现审计模板（PR 直用）</li>
<li>附录 H/I：端到端案例（secp 与 hash/Merkle）</li>
<li>附录 C：RISC-V 专题（ISA 治理链、扩展引入路线）</li>
<li>附录 B+D：术语定义与交叉索引</li>
<li>附录 E：图号与出版规范</li>
<li>附录 G：作者终版改稿清单</li>
</ul>
<h2 id="本地预览"><a class="header" href="#本地预览">本地预览</a></h2>
<pre><code class="language-bash">cd docs/riscv-vm-book/mdbook
mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>这本书不是在讲“某个虚拟机项目如何实现”，而是在回答一个长期问题：</p>
<ul>
<li>为什么区块链执行层最终会收敛到“可验证的小型操作系统”形态？</li>
<li>为什么在这类系统中，Rust 与 RISC-V 组合会成为高概率选择？</li>
</ul>
<p>全书采用“代码证据 -&gt; 架构判断 -&gt; 风险评估”的写法。</p>
<ul>
<li>代码证据来自 <code>ckb-vm</code> 仓库中的核心实现。</li>
<li>架构判断聚焦共识安全、可维护性和长期治理。</li>
<li>风险评估强调真实代价，而不是宣传口径。</li>
</ul>
<h2 id="读者收益"><a class="header" href="#读者收益">读者收益</a></h2>
<p>读完本书，你将掌握三件事：</p>
<ol>
<li>能从操作系统视角拆解区块链 VM 的执行主线。</li>
<li>能独立评估 Rust + RISC-V 方案在共识系统中的利弊。</li>
<li>能把“性能优化”与“共识确定性”放在同一个分析框架里。</li>
</ol>
<h2 id="阅读建议"><a class="header" href="#阅读建议">阅读建议</a></h2>
<ul>
<li>工程读者：按章节顺序阅读，重点看第 2、3、4、8、11 章。</li>
<li>密码学读者：重点看第 10 章与附录 A。</li>
<li>架构评审读者：重点看第 1 章与第 11 章。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 1 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-1-章-共识机器优先区块链-vm-的第一性原理"><a class="header" href="#第-1-章-共识机器优先区块链-vm-的第一性原理">第 1 章 共识机器优先：区块链 VM 的第一性原理</a></h1>
<h2 id="11-核心问题"><a class="header" href="#11-核心问题">1.1 核心问题</a></h2>
<p>区块链虚拟机到底是什么？它不是“跑得越快越好”的通用执行器，而是一个共识状态机的一部分。它的首要目标是：</p>
<ul>
<li>同输入下的确定输出</li>
<li>可计费的资源消耗</li>
<li>可重放的错误与中断路径</li>
</ul>
<h2 id="12-图-1-1共识-vm-的约束层级"><a class="header" href="#12-图-1-1共识-vm-的约束层级">1.2 图 1-1：共识 VM 的约束层级</a></h2>
<pre><code class="language-text">+------------------------------+
| 协议约束: 可验证/可回放      |
+------------------------------+
| 经济约束: 可计费/抗 DoS      |
+------------------------------+
| 工程约束: 可维护/可审计      |
+------------------------------+
| 执行优化: Trace/ASM/MOP      |
+------------------------------+
</code></pre>
<p>关键判断：性能优化位于最底层，必须服从上层约束。</p>
<h2 id="13-代码证据"><a class="header" href="#13-代码证据">1.3 代码证据</a></h2>
<p><code>src/machine/mod.rs</code> 的 <code>SupportMachine::add_cycles</code> 直接把“执行动作”和“计费上限”耦合在一起：</p>
<ul>
<li>溢出即 <code>CyclesOverflow</code></li>
<li>超上限即 <code>CyclesExceeded</code></li>
</ul>
<p><code>src/error.rs</code> 将这些状态提升为协议可观察错误，而非日志级事件。</p>
<h2 id="14-深度分析"><a class="header" href="#14-深度分析">1.4 深度分析</a></h2>
<p>传统本地 VM 可以容忍“某些极端路径行为差异”，但共识 VM 不行。只要某个节点在边界条件上产生不同结果，就可能触发分叉。<code>ckb-vm</code> 的策略是：</p>
<ul>
<li>先定义不可变语义边界</li>
<li>再在边界内做性能优化</li>
</ul>
<p>这就是为什么它同时强调 <code>Pause</code>、<code>reset_signal</code>、<code>cycles</code>：这些不是运行时“便捷功能”，而是共识控制面。</p>
<h2 id="15-案例dos-防护不是防火墙而是计费模型"><a class="header" href="#15-案例dos-防护不是防火墙而是计费模型">1.5 案例：DoS 防护不是防火墙，而是计费模型</a></h2>
<p>若某条指令链在不同节点上消耗可变、且无上限约束，攻击者可构造输入拖慢部分节点。<code>ckb-vm</code> 的 cycles 模型让这种攻击从“技术问题”变成“经济问题”：你可以发起重计算，但必须按协议付费。</p>
<h2 id="16-术语表本章"><a class="header" href="#16-术语表本章">1.6 术语表（本章）</a></h2>
<ul>
<li><code>Determinism</code>：同输入同输出同错误路径。</li>
<li><code>Cycle Budget</code>：执行预算上限。</li>
<li><code>Consensus Safety</code>：不因实现差异引发状态分歧。</li>
</ul>
<h2 id="17-一针见血结论"><a class="header" href="#17-一针见血结论">1.7 一针见血结论</a></h2>
<p>区块链 VM 的第一性原理不是吞吐率，而是可证明的一致执行。</p>
<h2 id="18-反例分析把高-tps当成唯一目标"><a class="header" href="#18-反例分析把高-tps当成唯一目标">1.8 反例分析：把“高 TPS”当成唯一目标</a></h2>
<p>反例场景：某 VM 团队只追求吞吐，弱化确定性与计费边界，结果出现两类问题：</p>
<ul>
<li>不同硬件节点在边界输入上出现行为差异，触发共识风险。</li>
<li>资源消耗缺乏稳定上限，攻击者可利用低成本构造 DoS 交易。</li>
</ul>
<p>教训：区块链 VM 的正确目标函数是“确定性 + 可定价 + 可维护”，性能必须在该约束内优化。</p>
<h2 id="19-架构评审清单出版版"><a class="header" href="#19-架构评审清单出版版">1.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否存在全局一致的 cycles 预算模型与超限错误语义。</li>
<li><input disabled="" type="checkbox"> 是否保证相同输入在不同平台上得到相同输出和错误码。</li>
<li><input disabled="" type="checkbox"> 是否将中断、恢复、失败路径显式纳入状态机。</li>
<li><input disabled="" type="checkbox"> 是否为 DoS 场景建立了经济成本防线（而非仅靠节点配置）。</li>
</ul>
<h2 id="110-参考实现清单代码锚点"><a class="header" href="#110-参考实现清单代码锚点">1.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/machine/mod.rs</code>: <code>SupportMachine::add_cycles</code>, <code>Pause</code></li>
<li><code>src/error.rs</code>: <code>Error::CyclesExceeded</code>, <code>Error::CyclesOverflow</code></li>
<li><code>src/cost_model.rs</code>: <code>estimate_cycles</code>（计费模型入口）</li>
</ul>
<h2 id="111-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#111-术语索引交叉参见附录-b-与附录-d">1.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Determinism</code></li>
<li><code>Cycle Budget</code></li>
<li><code>Consensus Safety</code></li>
</ul>
<h2 id="112-审稿人问题清单出版评审"><a class="header" href="#112-审稿人问题清单出版评审">1.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>本章是否明确区分了“确定性目标”与“性能目标”的优先级？</li>
<li>cycles 上限与错误语义是否被解释为协议约束而非实现细节？</li>
<li>是否给出了至少一个 DoS 经济学层面的反证场景？</li>
<li>论证是否可由 <code>src/machine/mod.rs</code> 与 <code>src/error.rs</code> 直接验证？</li>
<li>“一针见血结论”是否与前文证据严格对应？</li>
<li>本章结论是否对后续章节形成约束关系而非口号？</li>
</ol>
<h2 id="113-深入论证共识确定性的最小证明草图"><a class="header" href="#113-深入论证共识确定性的最小证明草图">1.13 深入论证：共识确定性的最小证明草图</a></h2>
<p>从工程角度，可以把“共识确定性”拆成三条可验证不变量：</p>
<ol>
<li><code>同输入同状态转移</code>：同一程序字节和参数，必须命中同一解码与执行语义。</li>
<li><code>同输入同资源消耗上界</code>：cycles 累计与超限行为必须一致。</li>
<li><code>同输入同失败语义</code>：错误类型和触发条件必须确定。</li>
</ol>
<p><code>ckb-vm</code> 的价值在于把这三条不变量映射到了明确代码层：</p>
<ul>
<li>状态转移：<code>execute_instruction</code> + <code>Machine</code> trait</li>
<li>资源约束：<code>SupportMachine::add_cycles</code></li>
<li>失败语义：<code>Error</code> 枚举</li>
</ul>
<p>这意味着审计可以围绕不变量进行，而不是围绕“代码风格”进行。</p>
<h2 id="114-深度案例故障注入式一致性验证"><a class="header" href="#114-深度案例故障注入式一致性验证">1.14 深度案例：故障注入式一致性验证</a></h2>
<p>建议建立以下故障注入矩阵：</p>
<ul>
<li>输入级：非法 ELF、超长 argv、边界地址读写</li>
<li>执行级：pause 信号、max_cycles 极小值、非法 syscall</li>
<li>版本级：<code>VERSION0/1/2</code> 切换</li>
</ul>
<p>每个注入点验证三件事：</p>
<ul>
<li>错误码是否一致</li>
<li>PC/寄存器回退语义是否一致</li>
<li>快照恢复后是否可重放</li>
</ul>
<p>如果上述三项可稳定通过，基本可证明“异常路径的共识安全性”不是偶然。</p>
<h2 id="115-实战建议把确定性评审前置到-pr-模板"><a class="header" href="#115-实战建议把确定性评审前置到-pr-模板">1.15 实战建议：把“确定性评审”前置到 PR 模板</a></h2>
<p>推荐在 PR 检查里加入两个强制问题：</p>
<ol>
<li>本改动是否改变任何输入到错误码的映射？</li>
<li>本改动是否改变任何输入到 cycles 累积的映射？</li>
</ol>
<h2 id="只要回答是可能改变就必须附差分报告与回滚策略"><a class="header" href="#只要回答是可能改变就必须附差分报告与回滚策略">只要回答是“可能改变”，就必须附差分报告与回滚策略。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 2 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-2-章-从-run-到-exit执行主流程的可审计链条"><a class="header" href="#第-2-章-从-run-到-exit执行主流程的可审计链条">第 2 章 从 run 到 exit：执行主流程的可审计链条</a></h1>
<h2 id="21-核心问题"><a class="header" href="#21-核心问题">2.1 核心问题</a></h2>
<p>一段合约二进制在 <code>ckb-vm</code> 中如何从字节变成退出码？</p>
<h2 id="22-图-2-1最短执行链"><a class="header" href="#22-图-2-1最短执行链">2.2 图 2-1：最短执行链</a></h2>
<pre><code class="language-text">run_with_memory
  -&gt; DefaultCoreMachine::new_with_memory
  -&gt; RustDefaultMachineBuilder::build
  -&gt; TraceMachine::new
  -&gt; load_program
       -&gt; load_elf
       -&gt; initialize_stack
  -&gt; run_with_decoder loop
       -&gt; decode
       -&gt; add_cycles
       -&gt; execute
       -&gt; ecall/ebreak
  -&gt; exit_code
</code></pre>
<p>代码入口位于 <code>src/lib.rs</code>。</p>
<h2 id="23-代码证据"><a class="header" href="#23-代码证据">2.3 代码证据</a></h2>
<p><code>DefaultMachine::load_program</code>（<code>src/machine/mod.rs</code>）将装载拆成两段：</p>
<ul>
<li><code>load_elf</code>：写入代码与数据页</li>
<li><code>initialize</code>：初始化 syscall/debugger + stack</li>
</ul>
<p><code>DefaultMachineRunner::run_with_decoder</code> 保证每轮执行都经过三道门：</p>
<ol>
<li>中断检查（<code>Pause</code>）</li>
<li>重置检查（<code>reset_signal</code>）</li>
<li>指令步进（<code>step</code>）</li>
</ol>
<h2 id="24-深度分析"><a class="header" href="#24-深度分析">2.4 深度分析</a></h2>
<p>这条链条的价值在于“层次边界清晰”：</p>
<ul>
<li>装载层只处理映像和内存状态。</li>
<li>执行层只处理取指、解码、执行。</li>
<li>系统调用层只在 <code>ecall</code> 发生时介入。</li>
</ul>
<p>这种分层减少了隐藏副作用，提升了审计效率。</p>
<h2 id="25-案例为什么-exit93-是内建而不是插件"><a class="header" href="#25-案例为什么-exit93-是内建而不是插件">2.5 案例：为什么 <code>exit(93)</code> 是内建而不是插件</a></h2>
<p><code>Machine::ecall</code> 中只内建处理 93 号 syscall（退出），其余交由外部 <code>Syscalls</code> 插件处理。原因是：退出语义属于 VM 最小闭环能力，必须由内核稳定定义；外部能力应该是可替换模块，而非核心耦合逻辑。</p>
<h2 id="26-术语表本章"><a class="header" href="#26-术语表本章">2.6 术语表（本章）</a></h2>
<ul>
<li><code>Runner</code>：驱动 VM 生命周期的循环控制器。</li>
<li><code>CoreMachine</code>：寄存器、PC、内存等基础状态接口。</li>
<li><code>SupportMachine</code>：在 CoreMachine 之上增加 cycles、load、reset 等能力。</li>
</ul>
<h2 id="27-一针见血结论"><a class="header" href="#27-一针见血结论">2.7 一针见血结论</a></h2>
<p><code>ckb-vm</code> 的主流程不是“调用方便”，而是“审计友好”：路径短、状态少、边界硬。</p>
<h2 id="28-反例分析单体运行循环与隐式副作用"><a class="header" href="#28-反例分析单体运行循环与隐式副作用">2.8 反例分析：单体运行循环与隐式副作用</a></h2>
<p>反例场景：把装载、执行、宿主调用、调试输出混在同一循环里，短期开发快，但长期出现：</p>
<ul>
<li>状态修改路径难追踪，审计复杂度指数上升。</li>
<li>线上 bug 难复现，尤其在异常路径和重入路径。</li>
</ul>
<p>教训：主流程必须分层，且每层职责可单独验证。</p>
<h2 id="29-架构评审清单出版版"><a class="header" href="#29-架构评审清单出版版">2.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 主流程是否可画出无歧义状态图（load/run/exit）。</li>
<li><input disabled="" type="checkbox"> <code>load_program</code> 与 <code>run</code> 的副作用边界是否清晰。</li>
<li><input disabled="" type="checkbox"> <code>ecall</code> 和异常返回码是否有稳定定义。</li>
<li><input disabled="" type="checkbox"> 是否支持在中断点安全恢复并保持结果一致。</li>
</ul>
<h2 id="210-参考实现清单代码锚点"><a class="header" href="#210-参考实现清单代码锚点">2.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/lib.rs</code>: <code>run</code>, <code>run_with_memory</code></li>
<li><code>src/machine/mod.rs</code>: <code>DefaultMachine::load_program</code>, <code>DefaultMachineRunner::run_with_decoder</code>, <code>Machine::ecall</code></li>
<li><code>src/decoder.rs</code>: <code>InstDecoder</code>, <code>DefaultDecoder</code></li>
</ul>
<h2 id="211-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#211-术语索引交叉参见附录-b-与附录-d">2.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Runner</code></li>
<li><code>CoreMachine</code></li>
<li><code>SupportMachine</code></li>
<li><code>Ecall</code></li>
</ul>
<h2 id="212-审稿人问题清单出版评审"><a class="header" href="#212-审稿人问题清单出版评审">2.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>执行主线是否在单张流程中闭环到 <code>exit_code</code>？</li>
<li>是否清晰解释了 load/run/ecall 的边界职责？</li>
<li>是否指出了中断与重置路径的审计价值？</li>
<li>是否避免把宿主逻辑混入 VM 主循环叙事？</li>
<li>本章代码锚点是否覆盖了入口、循环、退出三段？</li>
<li>章节结论是否可用于指导实际架构评审？</li>
</ol>
<h2 id="213-状态机细化从入口到退出的关键状态点"><a class="header" href="#213-状态机细化从入口到退出的关键状态点">2.13 状态机细化：从入口到退出的关键状态点</a></h2>
<p>可以把执行生命周期形式化为 7 个状态：</p>
<ol>
<li><code>Created</code>：机器已构造，未加载程序</li>
<li><code>LoadedELF</code>：段已装载，入口已写入 PC</li>
<li><code>StackReady</code>：参数与栈 ABI 完成</li>
<li><code>Running</code>：循环取指执行</li>
<li><code>Trapped</code>：发生 ecall/ebreak/pause</li>
<li><code>Exited</code>：exit_code 已稳定</li>
<li><code>Errored</code>：返回结构化 Error</li>
</ol>
<p>其中 <code>Running -&gt; Trapped -&gt; Running</code> 是可循环路径，<code>Exited/Errored</code> 为终态。</p>
<h2 id="214-栈布局示例64-位"><a class="header" href="#214-栈布局示例64-位">2.14 栈布局示例（64 位）</a></h2>
<p>以 <code>argc=2</code>、参数 <code>['foo','bar']</code> 为例，初始化后栈从高地址向低地址大致包含：</p>
<ul>
<li>对齐填充</li>
<li><code>argv[2]=NULL</code></li>
<li><code>argv[1]=ptr('bar')</code></li>
<li><code>argv[0]=ptr('foo')</code></li>
<li><code>argc=2</code></li>
<li>字符串区域 <code>foo bar </code></li>
</ul>
<p>这解释了为何 <code>initialize_stack</code> 需要先写字符串再倒序压入指针与 <code>argc</code>。</p>
<h2 id="215-读者实验手工追踪一次-run"><a class="header" href="#215-读者实验手工追踪一次-run">2.15 读者实验：手工追踪一次 <code>run()</code></a></h2>
<p>建议做一次最小实验：</p>
<ol>
<li>用 <code>examples/ckb_vm_runner.rs</code> 跑一个会 <code>exit(0)</code> 的最小程序。</li>
<li>在 <code>load_program</code> 后打印 PC/SP。</li>
<li>在每次 step 后打印 <code>pc/cycles/a0/a7</code>。</li>
</ol>
<h2 id="这个实验能快速建立代码-状态-结果的直觉映射"><a class="header" href="#这个实验能快速建立代码-状态-结果的直觉映射">这个实验能快速建立“代码-状态-结果”的直觉映射。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 3 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-3-章-elf-装载与内存权限把外部程序变成受控状态"><a class="header" href="#第-3-章-elf-装载与内存权限把外部程序变成受控状态">第 3 章 ELF 装载与内存权限：把外部程序变成受控状态</a></h1>
<h2 id="31-核心问题"><a class="header" href="#31-核心问题">3.1 核心问题</a></h2>
<p>为什么 VM 装载器是安全边界的一部分，而不仅是工具函数？</p>
<h2 id="32-图-3-1elf-到页动作的转换"><a class="header" href="#32-图-3-1elf-到页动作的转换">3.2 图 3-1：ELF 到页动作的转换</a></h2>
<pre><code class="language-text">ELF bytes
  -&gt; parse_elf
      -&gt; ProgramMetadata
          -&gt; [LoadingAction...]
              (addr,size,flags,source,offset)
  -&gt; load_binary_inner
      -&gt; init_pages per action
      -&gt; set PC = entry
</code></pre>
<h2 id="33-代码证据"><a class="header" href="#33-代码证据">3.3 代码证据</a></h2>
<p><code>src/elf.rs</code> 的 <code>parse_elf</code> 明确生成 <code>ProgramMetadata</code>，不是直接把 ELF 结构散用在执行路径里。</p>
<p><code>convert_flags</code> 实施两项硬拒绝：</p>
<ul>
<li>段不可读，拒绝</li>
<li>段可写且可执行，拒绝</li>
</ul>
<p><code>src/memory/wxorx.rs</code> 的 <code>WXorXMemory</code> 在运行期继续强制权限：</p>
<ul>
<li>取指必须落在 <code>FLAG_EXECUTABLE</code></li>
<li>写入必须落在 <code>FLAG_WRITABLE</code></li>
</ul>
<h2 id="34-深度分析"><a class="header" href="#34-深度分析">3.4 深度分析</a></h2>
<p>这是一种“操作系统式”装载模型：</p>
<ul>
<li>映像装载阶段决定页级权限</li>
<li>执行阶段持续检查权限</li>
<li>违规立即终止</li>
</ul>
<p>好处是把“代码注入”和“越权写入”从潜在漏洞变成确定错误。</p>
<h2 id="35-案例wx-为什么对链上-vm-尤其关键"><a class="header" href="#35-案例wx-为什么对链上-vm-尤其关键">3.5 案例：W^X 为什么对链上 VM 尤其关键</a></h2>
<p>在链上环境，攻击者可反复提交精心构造输入。若 VM 允许同页可写可执行，攻击面会从“输入漏洞”升级为“执行模型漏洞”。<code>WXorXMemory</code> 把这条路堵死，代价是需要更严格的装载策略，但这是共识层必须承担的代价。</p>
<h2 id="36-术语表本章"><a class="header" href="#36-术语表本章">3.6 术语表（本章）</a></h2>
<ul>
<li><code>W^X</code>：页不可同时写且执行。</li>
<li><code>LoadingAction</code>：一次页初始化动作描述。</li>
<li><code>Entry Point</code>：程序入口 PC。</li>
</ul>
<h2 id="37-一针见血结论"><a class="header" href="#37-一针见血结论">3.7 一针见血结论</a></h2>
<p>安全的 VM 装载器不是“读文件”，而是“建立可验证地址空间契约”。</p>
<h2 id="38-反例分析先写后验的权限模型"><a class="header" href="#38-反例分析先写后验的权限模型">3.8 反例分析：先写后验的权限模型</a></h2>
<p>反例场景：先把段写进内存，再在运行时“尽量检查权限”，会导致：</p>
<ul>
<li>历史脏数据与权限信息耦合，难以证明不存在执行注入路径。</li>
<li>检查逻辑分散在指令实现中，容易遗漏边界页。</li>
</ul>
<p>教训：权限应在装载期建模，在执行期强校验，且以页为单位统一处理。</p>
<h2 id="39-架构评审清单出版版"><a class="header" href="#39-架构评审清单出版版">3.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否拒绝可写且可执行段（W^X）。</li>
<li><input disabled="" type="checkbox"> ELF <code>PT_LOAD</code> 的地址/长度/偏移是否有越界保护。</li>
<li><input disabled="" type="checkbox"> 页对齐与跨页访问是否有一致语义。</li>
<li><input disabled="" type="checkbox"> 栈初始化是否有版本兼容与对齐保证。</li>
</ul>
<h2 id="310-参考实现清单代码锚点"><a class="header" href="#310-参考实现清单代码锚点">3.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/elf.rs</code>: <code>parse_elf</code>, <code>convert_flags</code>, <code>ProgramMetadata</code></li>
<li><code>src/memory/wxorx.rs</code>: <code>WXorXMemory::init_pages</code>, <code>execute_load32</code>, <code>store_bytes</code></li>
<li><code>src/machine/mod.rs</code>: <code>load_binary_inner</code>, <code>initialize_stack</code></li>
</ul>
<h2 id="311-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#311-术语索引交叉参见附录-b-与附录-d">3.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>ELF</code></li>
<li><code>W^X</code></li>
<li><code>ProgramMetadata</code></li>
<li><code>WXorXMemory</code></li>
</ul>
<h2 id="312-审稿人问题清单出版评审"><a class="header" href="#312-审稿人问题清单出版评审">3.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>ELF 到 <code>ProgramMetadata</code> 的转换是否解释了可验证性价值？</li>
<li>W^X 约束是否被说明为装载期 + 运行期双重机制？</li>
<li>是否覆盖了页对齐、越界、权限冲突三类边界错误？</li>
<li>栈初始化的版本兼容语义是否解释充分？</li>
<li>是否避免将“加载文件”误写成“单纯 I/O 操作”？</li>
<li>本章是否给出可执行的装载审计清单？</li>
</ol>
<h2 id="313-标志位映射表elf-段权限到页权限"><a class="header" href="#313-标志位映射表elf-段权限到页权限">3.13 标志位映射表：ELF 段权限到页权限</a></h2>
<p>建议把映射关系固定为审计检查表：</p>
<ul>
<li><code>R=1,W=0,X=1</code> -&gt; 可执行冻结页</li>
<li><code>R=1,W=1,X=0</code> -&gt; 可写页（旧版本允许冻结策略差异）</li>
<li><code>R=1,W=0,X=0</code> -&gt; 冻结只读页</li>
<li><code>R=0,*</code> -&gt; 直接拒绝</li>
<li><code>W=1,X=1</code> -&gt; 直接拒绝</li>
</ul>
<p>这张表能快速识别“权限提升”类回归风险。</p>
<h2 id="314-攻击视角装载器最容易出问题的三类边界"><a class="header" href="#314-攻击视角装载器最容易出问题的三类边界">3.14 攻击视角：装载器最容易出问题的三类边界</a></h2>
<ol>
<li><code>offset + filesz</code> 溢出导致越界切片</li>
<li>页面起始未对齐但被当作对齐页写入</li>
<li><code>offset_from_addr &gt; size</code> 导致外部数据定位错误</li>
</ol>
<p><code>ckb-vm</code> 在 <code>parse_elf</code> 与 <code>WXorXMemory::init_pages</code> 中对这些边界均有显式拒绝路径。</p>
<h2 id="315-工程建议装载阶段审计脚本最小集"><a class="header" href="#315-工程建议装载阶段审计脚本最小集">3.15 工程建议：装载阶段审计脚本最小集</a></h2>
<ul>
<li>脚本 1：扫描所有 <code>PT_LOAD</code> 是否满足 R/W/X 合法组合</li>
<li>脚本 2：验证 action 合并后地址区间不重叠异常</li>
<li>脚本 3：统计每类权限页数量，和历史基线对比</li>
</ul>
<h2 id="这些脚本不替代测试但能提前发现配置级事故"><a class="header" href="#这些脚本不替代测试但能提前发现配置级事故">这些脚本不替代测试，但能提前发现“配置级事故”。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 4 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-4-章-解码执行与-trace确定性边界内的性能工程"><a class="header" href="#第-4-章-解码执行与-trace确定性边界内的性能工程">第 4 章 解码、执行与 Trace：确定性边界内的性能工程</a></h1>
<h2 id="41-核心问题"><a class="header" href="#41-核心问题">4.1 核心问题</a></h2>
<p>解释器真的只能“慢速逐条执行”吗？</p>
<h2 id="42-图-4-1取指与解码快路径"><a class="header" href="#42-图-4-1取指与解码快路径">4.2 图 4-1：取指与解码快路径</a></h2>
<pre><code class="language-text">pc -&gt; decode_bits
  if not near page end:
     execute_load32 + RVC check
  else:
     execute_load16 (+ optional second load16)

-&gt; decode_raw (cache lookup)
-&gt; optional decode_mop fusion
-&gt; execute_instruction
</code></pre>
<h2 id="43-代码证据"><a class="header" href="#43-代码证据">4.3 代码证据</a></h2>
<ul>
<li><code>src/decoder.rs</code>：<code>decode_bits</code> 对页尾跨页场景做专门路径。</li>
<li><code>src/decoder.rs</code>：<code>instructions_cache</code> 避免重复解码热点地址。</li>
<li><code>src/decoder.rs</code>：<code>decode_mop</code> 将常见指令序列融合为宏操作。</li>
<li><code>src/machine/trace.rs</code>：Trace 缓存“基本块 + 处理函数指针”。</li>
</ul>
<h2 id="44-深度分析"><a class="header" href="#44-深度分析">4.4 深度分析</a></h2>
<p><code>ckb-vm</code> 的优化策略非常克制：</p>
<ul>
<li>不做不可解释的 speculative 优化</li>
<li>只做可审计的结构化优化</li>
</ul>
<p>它不是 JIT，但通过 <code>TraceMachine</code> 获取了局部线程化执行收益；通过 MOP 降低调度与解码开销；通过 decode cache 减少热点路径重复工作。</p>
<h2 id="45-案例密码学大整数路径上的收益来源"><a class="header" href="#45-案例密码学大整数路径上的收益来源">4.5 案例：密码学大整数路径上的收益来源</a></h2>
<p>大整数算法常出现固定算术模板（乘法、除法、进位链）。MOP 不是“换 ISA”，而是把“已知安全的指令组合”打包为同语义的复合动作，从而减少解释器开销。</p>
<h2 id="46-术语表本章"><a class="header" href="#46-术语表本章">4.6 术语表（本章）</a></h2>
<ul>
<li><code>RVC</code>：RISC-V 压缩指令集（16 位）。</li>
<li><code>MOP</code>：宏操作融合，把多条指令映射为一条复合操作。</li>
<li><code>Trace</code>：按基本块缓存的执行片段。</li>
</ul>
<h2 id="47-一针见血结论"><a class="header" href="#47-一针见血结论">4.7 一针见血结论</a></h2>
<p>在共识 VM 里，最好的性能优化不是最激进，而是最可证明。</p>
<h2 id="48-反例分析激进优化先行语义验证后补"><a class="header" href="#48-反例分析激进优化先行语义验证后补">4.8 反例分析：激进优化先行、语义验证后补</a></h2>
<p>反例场景：先上复杂 JIT，再补一致性校验，常见后果：</p>
<ul>
<li>优化命中路径与冷路径语义偏移。</li>
<li>cache/trace 失效策略不完整，出现不可重现错误。</li>
</ul>
<p>教训：共识执行器中，优化必须建立在可证明等价关系上。</p>
<h2 id="49-架构评审清单出版版"><a class="header" href="#49-架构评审清单出版版">4.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> decode cache 的失效条件是否完整（reset/版本切换/写代码页）。</li>
<li><input disabled="" type="checkbox"> MOP 融合是否有等价性测试与反例测试。</li>
<li><input disabled="" type="checkbox"> Trace 命中与未命中路径是否严格同语义。</li>
<li><input disabled="" type="checkbox"> slowpath 回退是否覆盖所有未优化 opcode。</li>
</ul>
<h2 id="410-参考实现清单代码锚点"><a class="header" href="#410-参考实现清单代码锚点">4.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/decoder.rs</code>: <code>decode_bits</code>, <code>decode_raw</code>, <code>decode_mop</code></li>
<li><code>src/machine/trace.rs</code>: <code>TraceMachine</code>, <code>run_with_decoder</code></li>
<li><code>src/instructions/execute.rs</code>: <code>execute_instruction</code>, <code>execute</code></li>
</ul>
<h2 id="411-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#411-术语索引交叉参见附录-b-与附录-d">4.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>RVC</code></li>
<li><code>MOP</code></li>
<li><code>Trace</code></li>
<li><code>Fast Path</code></li>
<li><code>Slow Path</code></li>
</ul>
<h2 id="412-审稿人问题清单出版评审"><a class="header" href="#412-审稿人问题清单出版评审">4.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>是否区分了解码优化与语义优化，避免概念混淆？</li>
<li>MOP/Trace 的收益是否建立在等价性前提上？</li>
<li>是否解释了 slowpath 回退对正确性的意义？</li>
<li>是否覆盖了页尾取指等边界路径？</li>
<li>本章是否提供了可复用的性能评审问题？</li>
<li>结论是否避免夸大为“解释器等同 JIT”？</li>
</ol>
<h2 id="413-解码缓存键设计为什么不是直接-pc--n"><a class="header" href="#413-解码缓存键设计为什么不是直接-pc--n">4.13 解码缓存键设计：为什么不是直接 <code>pc % N</code></a></h2>
<p><code>decode_raw</code> 的缓存键使用了混合位选择策略，目标是同时兼顾：</p>
<ul>
<li>局部顺序代码（函数体内部）</li>
<li>远跳转代码（库函数、分支目标）</li>
</ul>
<p>如果只用低位，热点函数命中高但远跳转退化严重；如果只用高位，局部热点退化。当前策略是折中工程选择。</p>
<h2 id="414-mop-等价性验证建议"><a class="header" href="#414-mop-等价性验证建议">4.14 MOP 等价性验证建议</a></h2>
<p>每条融合规则都应有三类测试：</p>
<ol>
<li>语义等价：融合前后寄存器/内存完全一致</li>
<li>边界等价：零寄存器、溢出、符号边界一致</li>
<li>长度等价：<code>instruction_length</code> 与 PC 前进一致</li>
</ol>
<p>只有三类都通过，MOP 才是“优化”而不是“语义变更”。</p>
<h2 id="415-trace-失效策略的审计点"><a class="header" href="#415-trace-失效策略的审计点">4.15 Trace 失效策略的审计点</a></h2>
<p>建议重点检查：</p>
<ul>
<li>reset 后 trace 是否清空</li>
<li>version 切换后旧 trace 是否不可复用</li>
<li>代码页被写时是否存在陈旧 trace 风险</li>
</ul>
<h2 id="共识-vm-里trace-失效策略错误的风险远大于-trace-命中率下降"><a class="header" href="#共识-vm-里trace-失效策略错误的风险远大于-trace-命中率下降">共识 VM 里，trace 失效策略错误的风险远大于 trace 命中率下降。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 5 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-5-章-syscall-与宿主边界最小可信计算基"><a class="header" href="#第-5-章-syscall-与宿主边界最小可信计算基">第 5 章 Syscall 与宿主边界：最小可信计算基</a></h1>
<h2 id="51-核心问题"><a class="header" href="#51-核心问题">5.1 核心问题</a></h2>
<p>VM 与宿主系统如何交互，才能既可扩展又不牺牲确定性？</p>
<h2 id="52-图-5-1ecall-分发路径"><a class="header" href="#52-图-5-1ecall-分发路径">5.2 图 5-1：<code>ecall</code> 分发路径</a></h2>
<pre><code class="language-text">guest ecall
  -&gt; Machine::ecall
      if A7 == 93:
         set exit_code, stop running
      else:
         for syscall module in syscalls:
            if module.ecall() handled: return
         error InvalidEcall
</code></pre>
<h2 id="53-代码证据"><a class="header" href="#53-代码证据">5.3 代码证据</a></h2>
<ul>
<li><code>src/machine/mod.rs</code>：<code>Machine::ecall</code> 内核仅处理退出。</li>
<li><code>src/syscalls/mod.rs</code>：<code>Syscalls</code> trait 规定 <code>initialize</code> + <code>ecall</code>。</li>
</ul>
<p>设计重点：内核只保留最小语义闭环，其余全部插件化。</p>
<h2 id="54-深度分析"><a class="header" href="#54-深度分析">5.4 深度分析</a></h2>
<p>这种设计像微内核：</p>
<ul>
<li>内核职责小：执行状态、陷入、错误语义</li>
<li>外部模块大：宿主能力、环境访问、I/O 代理</li>
</ul>
<p>优点：可信计算基收敛，安全评审范围更可控。缺点：宿主集成要显式实现更多桥接逻辑。</p>
<h2 id="55-案例调试输出-syscall"><a class="header" href="#55-案例调试输出-syscall">5.5 案例：调试输出 syscall</a></h2>
<p>示例 <code>examples/ckb_vm_runner.rs</code> 里的 <code>DebugSyscall</code> 读取 VM 内存字符串并输出日志。该能力不是 VM 内建，而是由宿主注入。这样既保留可扩展性，也避免把调试能力污染到共识内核。</p>
<h2 id="56-术语表本章"><a class="header" href="#56-术语表本章">5.6 术语表（本章）</a></h2>
<ul>
<li><code>Ecall</code>：从 guest 到 host 的系统调用陷入。</li>
<li><code>TCB</code>：Trusted Computing Base，可信计算基。</li>
<li><code>Module Chaining</code>：syscall 模块串行尝试处理。</li>
</ul>
<h2 id="57-一针见血结论"><a class="header" href="#57-一针见血结论">5.7 一针见血结论</a></h2>
<p>系统调用边界做得越小，协议安全边界就越清晰。</p>
<h2 id="58-反例分析把宿主能力塞进-vm-内核"><a class="header" href="#58-反例分析把宿主能力塞进-vm-内核">5.8 反例分析：把宿主能力塞进 VM 内核</a></h2>
<p>反例场景：为了“易用”，把文件系统、网络、时间等能力内建到 VM 核心，结果：</p>
<ul>
<li>TCB 快速膨胀，安全审计范围失控。</li>
<li>共识执行依赖宿主环境细节，跨节点一致性下降。</li>
</ul>
<p>教训：宿主能力必须模块化注入，核心只保留最小陷入语义。</p>
<h2 id="59-架构评审清单出版版"><a class="header" href="#59-架构评审清单出版版">5.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 内核默认 syscall 集是否最小化。</li>
<li><input disabled="" type="checkbox"> syscall 编号、参数、返回码是否有稳定 ABI。</li>
<li><input disabled="" type="checkbox"> 外部 syscall 模块是否可禁用、可替换、可审计。</li>
<li><input disabled="" type="checkbox"> 是否禁止宿主隐式副作用影响共识结果。</li>
</ul>
<h2 id="510-参考实现清单代码锚点"><a class="header" href="#510-参考实现清单代码锚点">5.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/machine/mod.rs</code>: <code>Machine::ecall</code>, <code>DefaultMachine::initialize</code></li>
<li><code>src/syscalls/mod.rs</code>: <code>Syscalls</code> trait</li>
<li><code>examples/ckb_vm_runner.rs</code>: <code>DebugSyscall</code> 参考实现</li>
</ul>
<h2 id="511-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#511-术语索引交叉参见附录-b-与附录-d">5.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Ecall</code></li>
<li><code>Syscalls Trait</code></li>
<li><code>TCB</code></li>
<li><code>Determinism</code></li>
</ul>
<h2 id="512-审稿人问题清单出版评审"><a class="header" href="#512-审稿人问题清单出版评审">5.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>是否明确内核与宿主能力的责任分界？</li>
<li><code>ecall</code> 默认最小语义是否解释到位？</li>
<li>插件式 syscall 的风险与收益是否平衡呈现？</li>
<li>是否讨论了 TCB 收敛与可扩展性的张力？</li>
<li>案例是否足够说明“能力注入而非内建堆叠”？</li>
<li>本章是否形成可执行的边界审计 checklist？</li>
</ol>
<h2 id="513-syscall-abi-契约模板"><a class="header" href="#513-syscall-abi-契约模板">5.13 Syscall ABI 契约模板</a></h2>
<p>建议在每个 syscall 说明中固定写明：</p>
<ul>
<li>编号（<code>A7</code>）</li>
<li>输入寄存器与内存约定</li>
<li>输出寄存器约定</li>
<li>失败错误码</li>
<li>是否影响 cycles</li>
</ul>
<p>这种模板化契约可以显著降低宿主实现偏差。</p>
<h2 id="514-能力最小化的两种实现模式"><a class="header" href="#514-能力最小化的两种实现模式">5.14 能力最小化的两种实现模式</a></h2>
<ol>
<li><code>内核固定最小集 + 外部插件扩展</code>（ckb-vm 当前模式）</li>
<li><code>内核全量能力 + 运行时开关</code>（不推荐）</li>
</ol>
<p>前者的优势是审计范围可控，后者常因“默认开启过多能力”引入隐性攻击面。</p>
<h2 id="515-实务建议syscall-改动发布门禁"><a class="header" href="#515-实务建议syscall-改动发布门禁">5.15 实务建议：syscall 改动发布门禁</a></h2>
<ul>
<li>必须附 ABI 变更对照表</li>
<li>必须附旧合约兼容性说明</li>
<li>必须附差分测试（有/无该 syscall 模块）</li>
</ul>
<h2 id="任何一项缺失都不应进入发布分支"><a class="header" href="#任何一项缺失都不应进入发布分支">任何一项缺失都不应进入发布分支。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 6 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-6-章-快照与恢复把执行过程对象化"><a class="header" href="#第-6-章-快照与恢复把执行过程对象化">第 6 章 快照与恢复：把执行过程对象化</a></h1>
<h2 id="61-核心问题"><a class="header" href="#61-核心问题">6.1 核心问题</a></h2>
<p>为什么区块链 VM 需要快照能力，而不仅是“跑完一次即结束”？</p>
<h2 id="62-图-6-1快照数据分层"><a class="header" href="#62-图-6-1快照数据分层">6.2 图 6-1：快照数据分层</a></h2>
<pre><code class="language-text">VM state
  = registers + pc + cycles + lr
  + memory pages

snapshot v1:
  dirty pages only

snapshot v2:
  dirty pages + pages_from_source(id,offset,length)
</code></pre>
<h2 id="63-代码证据"><a class="header" href="#63-代码证据">6.3 代码证据</a></h2>
<ul>
<li><code>src/snapshot.rs</code>：基础版脏页快照。</li>
<li><code>src/snapshot2.rs</code>：引入 <code>DataSource</code>，支持页面引用与去重。</li>
</ul>
<p><code>Snapshot2Context::make_snapshot</code> 会把内存页拆成两类：</p>
<ol>
<li>已知稳定来源页（不重复存内容）</li>
<li>真正写脏页（存增量内容）</li>
</ol>
<h2 id="64-深度分析"><a class="header" href="#64-深度分析">6.4 深度分析</a></h2>
<p>这背后的思想是“增量状态传输”：</p>
<ul>
<li>稳定数据不重复序列化</li>
<li>可变数据精准记录</li>
</ul>
<p>收益直接体现在：</p>
<ul>
<li>更小快照体积</li>
<li>更低网络/存储开销</li>
<li>更快恢复速度</li>
</ul>
<h2 id="65-案例长任务分段执行"><a class="header" href="#65-案例长任务分段执行">6.5 案例：长任务分段执行</a></h2>
<p>当单笔预算不足以完成复杂合约执行时，可以：</p>
<ol>
<li>运行至预算耗尽</li>
<li>生成快照</li>
<li>提高预算恢复执行</li>
</ol>
<p>只要快照语义确定，分段与一次性执行应得到同样状态结果。这是链上“长任务可支付化”的关键能力。</p>
<h2 id="66-术语表本章"><a class="header" href="#66-术语表本章">6.6 术语表（本章）</a></h2>
<ul>
<li><code>Dirty Page</code>：执行期间被写入的页。</li>
<li><code>DataSource</code>：外部稳定数据源抽象。</li>
<li><code>Resume</code>：从快照恢复执行状态。</li>
</ul>
<h2 id="67-一针见血结论"><a class="header" href="#67-一针见血结论">6.7 一针见血结论</a></h2>
<p>快照不是调试功能，而是区块链执行经济学的基础设施。</p>
<h2 id="68-反例分析全量快照与无版本恢复"><a class="header" href="#68-反例分析全量快照与无版本恢复">6.8 反例分析：全量快照与无版本恢复</a></h2>
<p>反例场景：每次保存全内存快照且恢复时不校验版本，短期简单，长期问题明显：</p>
<ul>
<li>快照体积大，网络与存储成本不可控。</li>
<li>升级后恢复语义可能偏移，埋下一致性风险。</li>
</ul>
<p>教训：快照要分层（来源页/脏页），恢复要强版本校验。</p>
<h2 id="69-架构评审清单出版版"><a class="header" href="#69-架构评审清单出版版">6.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 恢复时是否强制校验 VM 版本与关键参数。</li>
<li><input disabled="" type="checkbox"> 是否只保存必要增量状态而非全量内存。</li>
<li><input disabled="" type="checkbox"> 脏页标记与 source 页追踪是否可证明正确。</li>
<li><input disabled="" type="checkbox"> 分段执行与一次性执行是否可对拍验证。</li>
</ul>
<h2 id="610-参考实现清单代码锚点"><a class="header" href="#610-参考实现清单代码锚点">6.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/snapshot.rs</code>: <code>make_snapshot</code>, <code>resume</code></li>
<li><code>src/snapshot2.rs</code>: <code>Snapshot2Context</code>, <code>DataSource</code>, <code>make_snapshot</code>, <code>resume</code></li>
<li><code>src/memory/mod.rs</code>: <code>FLAG_DIRTY</code>, <code>get_page_indices</code></li>
</ul>
<h2 id="611-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#611-术语索引交叉参见附录-b-与附录-d">6.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Snapshot</code></li>
<li><code>Dirty Page</code></li>
<li><code>DataSource</code></li>
<li><code>ProgramMetadata</code></li>
</ul>
<h2 id="612-审稿人问题清单出版评审"><a class="header" href="#612-审稿人问题清单出版评审">6.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>快照被定位为“执行经济工具”而非调试工具，论证是否充分？</li>
<li>是否清晰比较 snapshot v1 与 snapshot2 的适用差异？</li>
<li>是否解释了 <code>DataSource</code> 对体积和恢复成本的影响？</li>
<li>恢复路径是否强调了版本校验与一致性验证？</li>
<li>是否给出分段执行与一次性执行对拍建议？</li>
<li>章节清单是否可直接用于上线前检查？</li>
</ol>
<h2 id="613-快照一致性不变量"><a class="header" href="#613-快照一致性不变量">6.13 快照一致性不变量</a></h2>
<p>恢复后必须满足以下不变量：</p>
<ol>
<li><code>pc/registers/cycles/max_cycles</code> 与快照一致</li>
<li>脏页内容一致，且页标志一致</li>
<li><code>lr</code>（load reservation）一致</li>
<li>恢复后继续执行结果与不中断执行一致</li>
</ol>
<p>这四条是“快照正确”最小充分集。</p>
<h2 id="614-snapshot2-的成本收益估算"><a class="header" href="#614-snapshot2-的成本收益估算">6.14 Snapshot2 的成本收益估算</a></h2>
<p>在典型链上场景中，程序代码与常量数据占比高，可通过 <code>pages_from_source</code> 去重。若脏页比例低，Snapshot2 在网络传输和存储上的收益会非常显著。</p>
<p>建议在文档中长期记录两个指标：</p>
<ul>
<li><code>dirty_pages / total_pages</code></li>
<li><code>pages_from_source / total_pages</code></li>
</ul>
<p>这能直观看到 Snapshot2 的真实收益。</p>
<h2 id="615-读者实验验证分段执行等价性"><a class="header" href="#615-读者实验验证分段执行等价性">6.15 读者实验：验证分段执行等价性</a></h2>
<p>实验步骤：</p>
<ol>
<li>设置极低 <code>max_cycles</code>，触发中断并保存快照。</li>
<li>恢复到新 VM，继续执行到完成。</li>
<li>与高预算一次性执行结果做对拍（寄存器/内存摘要）。</li>
</ol>
<h2 id="该实验是验证快照机制最有说服力的证据"><a class="header" href="#该实验是验证快照机制最有说服力的证据">该实验是验证快照机制最有说服力的证据。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 7 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-7-章-rust-类型系统把-isa-语义固定在编译期"><a class="header" href="#第-7-章-rust-类型系统把-isa-语义固定在编译期">第 7 章 Rust 类型系统：把 ISA 语义固定在编译期</a></h1>
<h2 id="71-核心问题"><a class="header" href="#71-核心问题">7.1 核心问题</a></h2>
<p>为什么 Rust 在这里是“语义工具”，不是“语法偏好”？</p>
<h2 id="72-图-7-1语义约束下沉到-trait"><a class="header" href="#72-图-7-1语义约束下沉到-trait">7.2 图 7-1：语义约束下沉到 trait</a></h2>
<pre><code class="language-text">Instruction handlers
   -&gt; Register trait methods
      -&gt; u32 / u64 concrete semantics

(no hidden cast / no UB shortcut)
</code></pre>
<h2 id="73-代码证据"><a class="header" href="#73-代码证据">7.3 代码证据</a></h2>
<p><code>src/instructions/register.rs</code> 的 <code>Register</code> trait 明确要求实现：</p>
<ul>
<li>溢出加减乘除与余数</li>
<li>signed/unsigned 比较</li>
<li>扩展位操作（B 扩展相关）</li>
<li><code>sign_extend</code> / <code>zero_extend</code></li>
</ul>
<p><code>src/instructions/utils.rs</code> 的 <code>update_register</code> 统一处理 x0 不可写不变量。</p>
<h2 id="74-深度分析"><a class="header" href="#74-深度分析">7.4 深度分析</a></h2>
<p>在共识系统里，最危险的错误不是崩溃，而是“不同节点得到不同结果”。Rust 的价值在于把大量语义边界变为编译期接口契约，并通过 <code>Result&lt;_, Error&gt;</code> 把失败路径显式化。</p>
<p>这并不自动等于“无 bug”，但显著降低了“隐式未定义行为”进入共识层的概率。</p>
<h2 id="75-案例除零与有符号溢出"><a class="header" href="#75-案例除零与有符号溢出">7.5 案例：除零与有符号溢出</a></h2>
<p>RISC-V 对除零、最小负数除以 -1 有严格规定。<code>Register</code> 的 <code>overflowing_div_*</code> 系列将这些规则固化，不依赖平台 CPU 的默认行为，从源头减少跨平台偏差。</p>
<h2 id="76-术语表本章"><a class="header" href="#76-术语表本章">7.6 术语表（本章）</a></h2>
<ul>
<li><code>Semantic Contract</code>：语义契约。</li>
<li><code>UB</code>：Undefined Behavior，未定义行为。</li>
<li><code>Zero Register</code>：RISC-V x0，恒为 0。</li>
</ul>
<h2 id="77-一针见血结论"><a class="header" href="#77-一针见血结论">7.7 一针见血结论</a></h2>
<p>Rust 在共识 VM 的核心收益是“把语义边界前移到类型系统”。</p>
<h2 id="78-反例分析依赖宿主整数默认行为"><a class="header" href="#78-反例分析依赖宿主整数默认行为">7.8 反例分析：依赖宿主整数默认行为</a></h2>
<p>反例场景：在指令实现中直接使用宿主语言隐式转换与未约束溢出行为：</p>
<ul>
<li>边界输入在不同编译器/平台可能产生差异。</li>
<li>语义分散在代码细节里，难以系统验证。</li>
</ul>
<p>教训：ISA 边界语义必须集中到统一抽象层（如 <code>Register</code> trait）。</p>
<h2 id="79-架构评审清单出版版"><a class="header" href="#79-架构评审清单出版版">7.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 除零、溢出、符号扩展是否由统一接口定义。</li>
<li><input disabled="" type="checkbox"> x0 等架构不变量是否有单点实现。</li>
<li><input disabled="" type="checkbox"> 错误是否通过结构化类型而非字符串传播。</li>
<li><input disabled="" type="checkbox"> 32/64 位路径是否共享同一语义模型。</li>
</ul>
<h2 id="710-参考实现清单代码锚点"><a class="header" href="#710-参考实现清单代码锚点">7.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/instructions/register.rs</code>: <code>Register</code> trait 与 <code>u32/u64</code> 语义实现</li>
<li><code>src/instructions/utils.rs</code>: <code>update_register</code>（x0 不变量）</li>
<li><code>src/error.rs</code>: 结构化错误模型</li>
</ul>
<h2 id="711-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#711-术语索引交叉参见附录-b-与附录-d">7.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Determinism</code></li>
<li><code>Semantic Drift</code></li>
<li><code>Zero Register</code></li>
<li><code>Consensus Safety</code></li>
</ul>
<h2 id="712-审稿人问题清单出版评审"><a class="header" href="#712-审稿人问题清单出版评审">7.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li><code>Register</code> trait 是否被阐明为语义契约而非抽象技巧？</li>
<li>除零/溢出/符号扩展的边界语义是否可代码验证？</li>
<li>是否避免把 Rust 优势泛化为“天然无 bug”？</li>
<li>x0 不变量的单点实现是否解释清楚？</li>
<li>错误模型显式化是否与共识安全建立联系？</li>
<li>本章结论是否支持跨平台一致性评审？</li>
</ol>
<h2 id="713-语义接口设计原则可复用到其他-vm"><a class="header" href="#713-语义接口设计原则可复用到其他-vm">7.13 语义接口设计原则（可复用到其他 VM）</a></h2>
<p><code>Register</code> trait 的设计可抽象为三条原则：</p>
<ol>
<li>把 ISA 边界行为显式函数化</li>
<li>把平台相关行为隔离在实现层</li>
<li>把默认行为写成不可变约束（如 x0）</li>
</ol>
<p>这三条原则可直接迁移到其他执行器项目。</p>
<h2 id="714-风险提示trait-抽象并不自动免疫错误"><a class="header" href="#714-风险提示trait-抽象并不自动免疫错误">7.14 风险提示：trait 抽象并不自动免疫错误</a></h2>
<p>即使有 trait，仍可能出现：</p>
<ul>
<li>某个实现忘记保持边界语义</li>
<li>新增方法未被所有实现覆盖</li>
<li>优化路径绕过 trait 直接操作底层值</li>
</ul>
<p>因此需要配套“trait 合约测试集”，不是只靠编译通过。</p>
<h2 id="715-合约测试建议"><a class="header" href="#715-合约测试建议">7.15 合约测试建议</a></h2>
<p>建议为 <code>u32</code> 与 <code>u64</code> 分别构建同一批向量：</p>
<ul>
<li>除零</li>
<li>有符号最小值溢出</li>
<li>位扩展边界</li>
<li>旋转与位计数</li>
</ul>
<h2 id="并验证跨位宽的语义对应关系"><a class="header" href="#并验证跨位宽的语义对应关系">并验证跨位宽的语义对应关系。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 8 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-8-章-rust--asm-混合执行性能路径与语义锚点"><a class="header" href="#第-8-章-rust--asm-混合执行性能路径与语义锚点">第 8 章 Rust + ASM 混合执行：性能路径与语义锚点</a></h1>
<h2 id="81-核心问题"><a class="header" href="#81-核心问题">8.1 核心问题</a></h2>
<p>为什么不选“纯 Rust”或“纯汇编”，而是混合架构？</p>
<h2 id="82-图-8-1混合执行控制流"><a class="header" href="#82-图-8-1混合执行控制流">8.2 图 8-1：混合执行控制流</a></h2>
<pre><code class="language-text">ASM execute loop
  -&gt; return RET_* status
     - RET_DECODE_TRACE
     - RET_ECALL
     - RET_SLOWPATH
     - ...
  -&gt; Rust side handles status
     -&gt; maybe fallback execute_instruction
</code></pre>
<h2 id="83-代码证据"><a class="header" href="#83-代码证据">8.3 代码证据</a></h2>
<ul>
<li><code>build.rs</code>：按目标平台条件启用汇编后端。</li>
<li><code>src/machine/asm/mod.rs</code>：汇编返回状态码，Rust 统一处理。</li>
<li><code>src/machine/asm/traces.rs</code>：固定 trace 与动态 trace 支持。</li>
</ul>
<h2 id="84-深度分析"><a class="header" href="#84-深度分析">8.4 深度分析</a></h2>
<p>这种架构的分工是：</p>
<ul>
<li>Rust：语义中心、错误模型、边界控制</li>
<li>ASM：热点执行器、低层性能实现</li>
</ul>
<p>这是一种“以语义安全为中心的性能外包”模型。不是追求极致裸金属速度，而是追求“可控加速”。</p>
<h2 id="85-案例ret_slowpath-的设计意义"><a class="header" href="#85-案例ret_slowpath-的设计意义">8.5 案例：<code>RET_SLOWPATH</code> 的设计意义</a></h2>
<p>当汇编路径遇到慢路径指令，系统回退到 Rust <code>execute_instruction</code>。这保证了即使汇编快路径未覆盖所有情况，语义依旧闭环。工程上它降低了“汇编全覆盖”压力，也避免了性能优化绑架语义完整性。</p>
<h2 id="86-术语表本章"><a class="header" href="#86-术语表本章">8.6 术语表（本章）</a></h2>
<ul>
<li><code>Fast Path</code>：高频快路径。</li>
<li><code>Slow Path</code>：低频或复杂路径。</li>
<li><code>Semantic Anchor</code>：语义锚点，指最终正确性归属层。</li>
</ul>
<h2 id="87-一针见血结论"><a class="header" href="#87-一针见血结论">8.7 一针见血结论</a></h2>
<p>混合架构的正确姿势不是“让汇编统治一切”，而是“让汇编服务于 Rust 语义边界”。</p>
<h2 id="88-反例分析纯汇编快跑语义文档缺失"><a class="header" href="#88-反例分析纯汇编快跑语义文档缺失">8.8 反例分析：纯汇编快跑、语义文档缺失</a></h2>
<p>反例场景：性能后端快速迭代，但缺少与语义后端的对齐机制：</p>
<ul>
<li>新 opcode 在某后端生效、另一个后端未同步。</li>
<li>边界错误只能在线上暴露，回溯成本高。</li>
</ul>
<p>教训：快路径必须服从语义锚点，并配置长期差分测试。</p>
<h2 id="89-架构评审清单出版版"><a class="header" href="#89-架构评审清单出版版">8.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 汇编返回码与错误语义是否完整映射。</li>
<li><input disabled="" type="checkbox"> <code>RET_SLOWPATH</code> 回退链是否稳定可测。</li>
<li><input disabled="" type="checkbox"> Rust/ASM 是否有常态化差分回归。</li>
<li><input disabled="" type="checkbox"> 构建系统是否明确支持矩阵与回退策略。</li>
</ul>
<h2 id="810-参考实现清单代码锚点"><a class="header" href="#810-参考实现清单代码锚点">8.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>build.rs</code>: 汇编后端启用矩阵</li>
<li><code>src/machine/asm/mod.rs</code>: <code>RET_*</code> 状态码处理、<code>RET_SLOWPATH</code> 回退</li>
<li><code>src/machine/asm/traces.rs</code>: <code>TraceDecoder</code> 与 fixed/dynamic trace</li>
</ul>
<h2 id="811-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#811-术语索引交叉参见附录-b-与附录-d">8.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Fast Path</code></li>
<li><code>Slow Path</code></li>
<li><code>Differential Testing</code></li>
<li><code>Semantic Drift</code></li>
</ul>
<h2 id="812-审稿人问题清单出版评审"><a class="header" href="#812-审稿人问题清单出版评审">8.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>是否明确 Rust 与 ASM 的职责边界与主从关系？</li>
<li>是否解释 <code>RET_SLOWPATH</code> 对语义闭环的价值？</li>
<li>双后端一致性成本是否被充分揭示？</li>
<li>构建矩阵与平台限制是否说明完整？</li>
<li>是否给出差分测试作为长期治理机制？</li>
<li>结论是否避免“性能优先于语义”的误导？</li>
</ol>
<h2 id="813-双后端差分测试流水线建议"><a class="header" href="#813-双后端差分测试流水线建议">8.13 双后端差分测试流水线建议</a></h2>
<p>最小可行流水线：</p>
<ol>
<li>固定输入集（正常 + 边界 + 恶意）</li>
<li>分别在 Rust/ASM 后端执行</li>
<li>比较 <code>exit_code/cycles/register_digest/memory_digest</code></li>
<li>对差异自动归档并阻断合并</li>
</ol>
<p>这是控制语义漂移的核心基础设施。</p>
<h2 id="814-汇编快路径的文档要求"><a class="header" href="#814-汇编快路径的文档要求">8.14 汇编快路径的文档要求</a></h2>
<p>每个 <code>RET_*</code> 返回码应在文档中说明：</p>
<ul>
<li>触发条件</li>
<li>Rust 侧处理函数</li>
<li>对状态机的影响</li>
</ul>
<p>这样可以减少“后端懂的人太少”的知识孤岛风险。</p>
<h2 id="815-版本演进建议"><a class="header" href="#815-版本演进建议">8.15 版本演进建议</a></h2>
<p>当新增 opcode 或修复语义时，推荐顺序：</p>
<ol>
<li>先在 Rust 语义后端落地</li>
<li>补齐差分测试</li>
<li>再落汇编快路径</li>
</ol>
<h2 id="反过来做会显著提高回归风险"><a class="header" href="#反过来做会显著提高回归风险">反过来做会显著提高回归风险。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 9 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-9-章-为什么是-risc-v开放-isa-的长期治理价值"><a class="header" href="#第-9-章-为什么是-risc-v开放-isa-的长期治理价值">第 9 章 为什么是 RISC-V：开放 ISA 的长期治理价值</a></h1>
<h2 id="91-核心问题"><a class="header" href="#91-核心问题">9.1 核心问题</a></h2>
<p>ISA 选择对区块链协议意味着什么？</p>
<h2 id="92-图-9-1isa-选择影响链路"><a class="header" href="#92-图-9-1isa-选择影响链路">9.2 图 9-1：ISA 选择影响链路</a></h2>
<pre><code class="language-text">ISA selection
  -&gt; compiler/toolchain
  -&gt; contract ecosystem
  -&gt; verifier/auditor cost
  -&gt; protocol upgrade flexibility
</code></pre>
<h2 id="93-代码证据"><a class="header" href="#93-代码证据">9.3 代码证据</a></h2>
<p><code>ckb-vm</code> 体现了 RISC-V 的三类工程收益：</p>
<ul>
<li>规整编码：<code>src/decoder.rs</code> 能高效区分 RVC 与 32 位指令。</li>
<li>扩展可组合：IMC/B/A/MOP 通过 <code>isa</code> 位图控制。</li>
<li>32/64 统一框架：同一执行器通过 <code>Register</code> trait 兼容。</li>
</ul>
<h2 id="94-深度分析"><a class="header" href="#94-深度分析">9.4 深度分析</a></h2>
<p>在十年级协议生命周期里，ISA 不只是技术决策，也是治理决策：</p>
<ul>
<li>封闭 ISA 会引入长期法律和生态不确定性。</li>
<li>规整 ISA 更容易形成多实现与交叉验证。</li>
<li>开放 ISA 更利于教育、审计和工具链扩展。</li>
</ul>
<p>RISC-V 的价值更多是“降低长期维护摩擦”，而不是单次 benchmark 的优势。</p>
<h2 id="95-案例跨团队实现一致性"><a class="header" href="#95-案例跨团队实现一致性">9.5 案例：跨团队实现一致性</a></h2>
<p>当不同团队实现同一 VM 后端时，最难的是边界语义对齐。RISC-V 的公开规范与清晰编码有助于建立一致测试基线，降低“实现各自正确、系统整体分叉”的风险。</p>
<h2 id="96-术语表本章"><a class="header" href="#96-术语表本章">9.6 术语表（本章）</a></h2>
<ul>
<li><code>Open ISA</code>：开放指令集架构。</li>
<li><code>Multi-implementation</code>：同协议多实现并存。</li>
<li><code>Governance Cost</code>：长期治理成本。</li>
</ul>
<h2 id="97-一针见血结论"><a class="header" href="#97-一针见血结论">9.7 一针见血结论</a></h2>
<p>RISC-V 在共识 VM 中的核心优势，是长期可治理性，而非短期跑分胜负。</p>
<h2 id="98-反例分析把-isa-当作短期性能开关"><a class="header" href="#98-反例分析把-isa-当作短期性能开关">9.8 反例分析：把 ISA 当作短期性能开关</a></h2>
<p>反例场景：仅以短期 benchmark 选 ISA，忽略规范开放性与工具链治理：</p>
<ul>
<li>长期升级受制于外部授权或生态锁定。</li>
<li>多实现一致性验证成本居高不下。</li>
</ul>
<p>教训：共识系统的 ISA 选择首先是治理问题，其次才是性能问题。</p>
<h2 id="99-架构评审清单出版版"><a class="header" href="#99-架构评审清单出版版">9.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否存在公开、稳定、可引用的 ISA 规范。</li>
<li><input disabled="" type="checkbox"> 编译器/链接器/调试链路是否可重复构建。</li>
<li><input disabled="" type="checkbox"> 是否支持多实现对拍与生态扩展。</li>
<li><input disabled="" type="checkbox"> 协议升级是否有 ISA 层兼容策略。</li>
</ul>
<h2 id="910-参考实现清单代码锚点"><a class="header" href="#910-参考实现清单代码锚点">9.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/lib.rs</code>: ISA 组合默认启用位（IMC/B/A/MOP）</li>
<li><code>src/decoder.rs</code>: RVC + 32 位解码路径</li>
<li><code>README.md</code>: 目标 ISA 与使用模式说明</li>
</ul>
<h2 id="911-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#911-术语索引交叉参见附录-b-与附录-d">9.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Open ISA</code></li>
<li><code>Governance Cost</code></li>
<li><code>RVC</code></li>
<li><code>Execution Governance</code></li>
</ul>
<h2 id="912-审稿人问题清单出版评审"><a class="header" href="#912-审稿人问题清单出版评审">9.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>是否将 ISA 选择上升到治理成本层面？</li>
<li>是否阐明开放规范对多实现对拍的意义？</li>
<li>RISC-V 的优势是否避免流于口号（仅“开放”）？</li>
<li>章节是否连接到工具链与升级策略现实？</li>
<li>是否提出了可落地的 ISA 评估标准？</li>
<li>本章是否为附录 C 做了清晰铺垫？</li>
</ol>
<h2 id="913-isa-治理的三层决策"><a class="header" href="#913-isa-治理的三层决策">9.13 ISA 治理的三层决策</a></h2>
<p>在共识项目里，ISA 变更应至少通过三层评审：</p>
<ol>
<li>语义层：是否破坏既有合约执行预期</li>
<li>经济层：是否改变计费公平性</li>
<li>运维层：是否可灰度、可回滚、可监控</li>
</ol>
<p>仅通过性能评审不应发布。</p>
<h2 id="914-工具链可复现建议"><a class="header" href="#914-工具链可复现建议">9.14 工具链可复现建议</a></h2>
<p>建议固定并记录：</p>
<ul>
<li>编译器版本</li>
<li>链接参数</li>
<li>目标架构标志</li>
<li>产物哈希</li>
</ul>
<p>否则同源代码可能产生不同机器码，给审计带来巨大负担。</p>
<h2 id="915-教学价值开放-isa-的组织效益"><a class="header" href="#915-教学价值开放-isa-的组织效益">9.15 教学价值：开放 ISA 的组织效益</a></h2>
<h2 id="risc-v-的开放性带来的不只是技术自由还包括团队培养外部审计协作和社区工具复用效率这些长期效益往往比短期性能差异更关键"><a class="header" href="#risc-v-的开放性带来的不只是技术自由还包括团队培养外部审计协作和社区工具复用效率这些长期效益往往比短期性能差异更关键">RISC-V 的开放性带来的不只是“技术自由”，还包括团队培养、外部审计协作和社区工具复用效率，这些长期效益往往比短期性能差异更关键。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 10 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-10-章-密码学负载与指令扩展从-bma-到-mop"><a class="header" href="#第-10-章-密码学负载与指令扩展从-bma-到-mop">第 10 章 密码学负载与指令扩展：从 B/M/A 到 MOP</a></h1>
<h2 id="101-核心问题"><a class="header" href="#101-核心问题">10.1 核心问题</a></h2>
<p>为什么密码学合约需要的不只是“能跑”，而是“跑得可定价”？</p>
<h2 id="102-图-10-1密码学操作到扩展映射"><a class="header" href="#102-图-10-1密码学操作到扩展映射">10.2 图 10-1：密码学操作到扩展映射</a></h2>
<pre><code class="language-text">Big-int mul/div chain -&gt; M + MOP (WIDE_MUL/WIDE_DIV)
Bit permutation       -&gt; B (REV8/ORCB)
Carry-less arithmetic -&gt; B (CLMUL/CLMULH/CLMULR)
Atomic handshakes     -&gt; A (LR/SC/AMO)
</code></pre>
<h2 id="103-代码证据"><a class="header" href="#103-代码证据">10.3 代码证据</a></h2>
<ul>
<li><code>src/instructions/b.rs</code>：位操作与无进位乘法相关指令解码。</li>
<li><code>src/instructions/execute.rs</code>：<code>handle_wide_mul</code>, <code>handle_wide_div</code>, <code>handle_add3*</code>。</li>
<li><code>src/decoder.rs</code>：<code>decode_mop</code> 识别并融合高频序列。</li>
<li><code>src/cost_model.rs</code>：不同指令映射不同 cycle 开销。</li>
</ul>
<h2 id="104-深度分析"><a class="header" href="#104-深度分析">10.4 深度分析</a></h2>
<p>密码学负载常见瓶颈并不在“单条指令速度”，而在“长链操作的调度开销和计费公平性”。MOP 的意义在于：</p>
<ul>
<li>不改变最终语义</li>
<li>缩短解释层调度链</li>
<li>让计费模型更贴近真实复杂度</li>
</ul>
<h2 id="105-案例大整数乘加进位链"><a class="header" href="#105-案例大整数乘加进位链">10.5 案例：大整数乘加进位链</a></h2>
<p>大整数库中，<code>mul + add + carry</code> 模式极高频。若全部走单指令解释分发，会产生大量 dispatch 成本。MOP 将固定模式压缩后，能够在不破坏确定性的前提下降低单位计算成本。</p>
<h2 id="106-术语表本章"><a class="header" href="#106-术语表本章">10.6 术语表（本章）</a></h2>
<ul>
<li><code>Carry-less Multiply</code>：无进位乘法，常用于 GF(2) 运算。</li>
<li><code>Macro-Op Fusion</code>：宏操作融合。</li>
<li><code>Gas Fairness</code>：计费公平性。</li>
</ul>
<h2 id="107-一针见血结论"><a class="header" href="#107-一针见血结论">10.7 一针见血结论</a></h2>
<p>密码学友好 VM 的核心，不是指令“多”，而是把高频模式压缩成可预测成本。</p>
<h2 id="108-反例分析只做微基准不做真实负载画像"><a class="header" href="#108-反例分析只做微基准不做真实负载画像">10.8 反例分析：只做微基准，不做真实负载画像</a></h2>
<p>反例场景：通过单指令 microbenchmark 宣称优化成功，但上线后费用模型失真：</p>
<ul>
<li>热点负载并非该指令，实际收益有限。</li>
<li>cycles 估值偏差导致 DoS 面或过度收费。</li>
</ul>
<p>教训：密码学优化必须基于真实合约路径与端到端计费验证。</p>
<h2 id="109-架构评审清单出版版"><a class="header" href="#109-架构评审清单出版版">10.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否有 secp/hash/Merkle 等代表性 workload 的 profiling。</li>
<li><input disabled="" type="checkbox"> MOP 融合是否附带等价证明与回归测试。</li>
<li><input disabled="" type="checkbox"> cycles 参数是否按版本持续校准。</li>
<li><input disabled="" type="checkbox"> 是否明确区分确定性保证与恒时安全保证。</li>
</ul>
<h2 id="1010-参考实现清单代码锚点"><a class="header" href="#1010-参考实现清单代码锚点">10.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/instructions/b.rs</code>: B 扩展解码</li>
<li><code>src/instructions/execute.rs</code>: <code>handle_wide_mul</code>, <code>handle_wide_div</code>, <code>handle_add3*</code></li>
<li><code>src/decoder.rs</code>: <code>decode_mop</code></li>
<li><code>src/cost_model.rs</code>: <code>estimate_cycles</code></li>
</ul>
<h2 id="1011-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#1011-术语索引交叉参见附录-b-与附录-d">10.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>B Extension</code></li>
<li><code>M Extension</code></li>
<li><code>MOP</code></li>
<li><code>Gas Fairness</code></li>
</ul>
<h2 id="1012-审稿人问题清单出版评审"><a class="header" href="#1012-审稿人问题清单出版评审">10.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>密码学负载画像是否覆盖 secp/hash/Merkle 三类典型路径？</li>
<li>MOP 与扩展指令收益是否基于真实 workload 而非微基准？</li>
<li>计费公平性是否与安全风险绑定讨论？</li>
<li>是否区分了确定性与恒时安全的边界？</li>
<li>代码锚点是否足以复核核心论点？</li>
<li>本章是否能指导性能优化 PR 的审查？</li>
</ol>
<h2 id="1013-案例展开一次签名验证的大致执行剖面"><a class="header" href="#1013-案例展开一次签名验证的大致执行剖面">10.13 案例展开：一次签名验证的大致执行剖面</a></h2>
<p>以 secp256k1 验签为例，执行热点通常分布在：</p>
<ul>
<li>标量与点运算的大整数乘加链</li>
<li>模约简循环</li>
<li>少量控制流与内存搬运</li>
</ul>
<p>若记录 opcode 统计，常见现象是算术与位操作长期占据前列，这也是 B/M/MOP 优化优先级高的原因。</p>
<h2 id="1014-计费校准的常见误区"><a class="header" href="#1014-计费校准的常见误区">10.14 计费校准的常见误区</a></h2>
<ul>
<li>只看总耗时，不看 opcode 结构</li>
<li>只看单机，不看跨平台偏差</li>
<li>只看平均值，不看长尾交易</li>
</ul>
<p>正确方式应是“结构化统计 + 跨后端对拍 + 长尾分析”。</p>
<h2 id="1015-优化发布建议"><a class="header" href="#1015-优化发布建议">10.15 优化发布建议</a></h2>
<p>优化 PR 应至少附三份报告：</p>
<ol>
<li>语义等价报告</li>
<li>性能收益报告（真实 workload）</li>
<li>计费影响报告（费用曲线变化）</li>
</ol>
<h2 id="缺一不可"><a class="header" href="#缺一不可">缺一不可。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<blockquote>
<p>出版版章节 <code>第 11 章</code> | 文档版本 <code>v0.5.0</code> | 评审状态 <code>可审阅</code>
关联附录：术语见 <code>附录 B</code> 与 <code>附录 D</code></p>
</blockquote>
<h1 id="第-11-章-架构总评优势代价与下一步"><a class="header" href="#第-11-章-架构总评优势代价与下一步">第 11 章 架构总评：优势、代价与下一步</a></h1>
<h2 id="111-核心问题"><a class="header" href="#111-核心问题">11.1 核心问题</a></h2>
<p>这套架构真正赢在哪里？真实代价又是什么？</p>
<h2 id="112-图-11-1收益与成本矩阵"><a class="header" href="#112-图-11-1收益与成本矩阵">11.2 图 11-1：收益与成本矩阵</a></h2>
<pre><code class="language-text">收益侧:                       成本侧:
- 可验证执行                 - 双后端一致性维护
- 清晰权限边界               - cycles 模型校准压力
- 可恢复执行                 - syscall 生态集成复杂
- 渐进式性能优化             - 密码学侧信道防护额外投入
</code></pre>
<h2 id="113-优势判断"><a class="header" href="#113-优势判断">11.3 优势判断</a></h2>
<ol>
<li>执行边界清晰：装载、执行、syscall、快照职责分离。</li>
<li>协议兼容策略明确：<code>VERSION0/1/2</code> 保留历史语义。</li>
<li>优化路径可审计：trace/MOP/ASM 都可被代码定位和验证。</li>
<li>权限模型扎实：W^X 与冻结页机制降低注入面。</li>
</ol>
<h2 id="114-风险判断"><a class="header" href="#114-风险判断">11.4 风险判断</a></h2>
<ol>
<li>双执行后端一旦测试覆盖不足，存在分歧风险。</li>
<li><code>estimate_cycles</code> 需要持续与真实负载校准，否则会出现计费失真。</li>
<li>宿主扩展能力越多，边界管理复杂度越高。</li>
<li>当前确定性模型不自动提供恒时安全，需要密码学专项治理。</li>
</ol>
<h2 id="115-案例最容易被误判的优化方向"><a class="header" href="#115-案例最容易被误判的优化方向">11.5 案例：最容易被误判的优化方向</a></h2>
<p>常见误判是“先追求更激进 JIT，再补安全验证”。在共识场景里应反过来：</p>
<ul>
<li>先证明边界可控</li>
<li>再增量引入优化</li>
</ul>
<p>否则短期提速可能换来长期分叉风险。</p>
<h2 id="116-术语表本章"><a class="header" href="#116-术语表本章">11.6 术语表（本章）</a></h2>
<ul>
<li><code>Differential Testing</code>：差分测试，比较多后端结果一致性。</li>
<li><code>Semantic Drift</code>：语义漂移，指实现与规范逐渐偏离。</li>
<li><code>Execution Governance</code>：执行层治理，指升级与兼容策略体系。</li>
</ul>
<h2 id="117-一针见血结论"><a class="header" href="#117-一针见血结论">11.7 一针见血结论</a></h2>
<p><code>ckb-vm</code> 的护城河不是“某项黑科技优化”，而是把共识执行做成了可治理的系统工程。</p>
<h2 id="118-反例分析没有升级护栏的快速演进"><a class="header" href="#118-反例分析没有升级护栏的快速演进">11.8 反例分析：没有升级护栏的“快速演进”</a></h2>
<p>反例场景：频繁升级执行层却缺少版本兼容和发布门禁：</p>
<ul>
<li>历史交易重放结果漂移，破坏链上可验证性。</li>
<li>运维侧难以判断升级影响半径。</li>
</ul>
<p>教训：执行层升级必须以可回滚、可验证、可量化影响为前提。</p>
<h2 id="119-架构评审清单出版版"><a class="header" href="#119-架构评审清单出版版">11.9 架构评审清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否有版本分层与历史语义保留策略。</li>
<li><input disabled="" type="checkbox"> 发布前是否进行跨后端、跨平台差分验证。</li>
<li><input disabled="" type="checkbox"> 是否有 cycles 模型与经济参数的联动评审。</li>
<li><input disabled="" type="checkbox"> 是否具备回滚预案与兼容性公告模板。</li>
</ul>
<h2 id="1110-参考实现清单代码锚点"><a class="header" href="#1110-参考实现清单代码锚点">11.10 参考实现清单（代码锚点）</a></h2>
<ul>
<li><code>src/machine/mod.rs</code>: <code>VERSION0/1/2</code>, <code>run_with_decoder</code></li>
<li><code>src/machine/asm/mod.rs</code>: 汇编后端返回码与慢路径回退</li>
<li><code>src/memory/wxorx.rs</code>: W^X 权限模型</li>
<li><code>src/cost_model.rs</code>: 计费模型参数化</li>
</ul>
<h2 id="1111-术语索引交叉参见附录-b-与附录-d"><a class="header" href="#1111-术语索引交叉参见附录-b-与附录-d">11.11 术语索引交叉（参见附录 B 与附录 D）</a></h2>
<ul>
<li><code>Differential Testing</code></li>
<li><code>Semantic Drift</code></li>
<li><code>Execution Governance</code></li>
<li><code>Cycle Budget</code></li>
</ul>
<h2 id="1112-审稿人问题清单出版评审"><a class="header" href="#1112-审稿人问题清单出版评审">11.12 审稿人问题清单（出版评审）</a></h2>
<ol>
<li>优势与代价是否对称呈现，避免单边叙事？</li>
<li>是否将“版本兼容”作为首要治理约束？</li>
<li>是否提供了可执行的发布门禁逻辑？</li>
<li>是否强调了差分测试与回滚预案的必要性？</li>
<li>章节结论是否能直接转化为架构决策标准？</li>
<li>本章是否与附录 E 的出版规范形成闭环？</li>
</ol>
<h2 id="1113-路线图细化12-个月可执行里程碑"><a class="header" href="#1113-路线图细化12-个月可执行里程碑">11.13 路线图细化：12 个月可执行里程碑</a></h2>
<p>建议按季度推进：</p>
<ul>
<li>Q1：完善差分测试与发布门禁</li>
<li>Q2：完善 cycles 校准自动化</li>
<li>Q3：完成密码学路径恒时审计基线</li>
<li>Q4：评估并试点新扩展（含回滚演练）</li>
</ul>
<p>每个季度要有可量化指标，而不是口号式目标。</p>
<h2 id="1114-指标体系建议"><a class="header" href="#1114-指标体系建议">11.14 指标体系建议</a></h2>
<p>推荐长期跟踪：</p>
<ul>
<li>后端差分失败率</li>
<li>热点 workload 的 cycles 漂移率</li>
<li>版本升级后的兼容回归率</li>
<li>安全审计发现密度</li>
</ul>
<p>这些指标能把“架构治理”从经验判断变为数据判断。</p>
<h2 id="1115-最终建议把文档当作协议资产"><a class="header" href="#1115-最终建议把文档当作协议资产">11.15 最终建议：把文档当作协议资产</a></h2>
<p>执行层文档不是宣传材料，而是协议资产。它应当具备：</p>
<ul>
<li>可追溯版本</li>
<li>可引用证据</li>
<li>可执行检查表</li>
</ul>
<h2 id="只有这样系统复杂度增长时才不会失控"><a class="header" href="#只有这样系统复杂度增长时才不会失控">只有这样，系统复杂度增长时才不会失控。</a></h2>
<blockquote>
<p>章末核查：本章已包含 <code>反例分析</code>、<code>架构评审清单</code>、<code>参考实现清单</code>、<code>术语索引交叉</code>、<code>审稿人问题清单</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图示拆解长文系列路线图分批实现"><a class="header" href="#图示拆解长文系列路线图分批实现">图示拆解长文系列路线图（分批实现）</a></h1>
<p>目标：把各章“图 X-1”从章内导图扩展为可独立阅读的深度文章，形成“图 -&gt; 架构 -&gt; 审计 -&gt; 落地”的完整链条。</p>
<h2 id="批次规划"><a class="header" href="#批次规划">批次规划</a></h2>
<h2 id="批次一已完成"><a class="header" href="#批次一已完成">批次一（已完成）</a></h2>
<ul>
<li><code>1-1</code> 共识 VM 约束层级：从抽象金字塔到协议门禁</li>
<li><code>2-1</code> run 到 exit 生命周期：状态机与失败语义</li>
<li><code>3-1</code> ELF 到页动作转换：装载器为何是安全边界</li>
<li><code>4-1</code> 取指与解码快路径：确定性边界内的性能工程</li>
</ul>
<h2 id="批次二已完成"><a class="header" href="#批次二已完成">批次二（已完成）</a></h2>
<ul>
<li><code>5-1</code> ecall 分发路径：最小可信计算基设计</li>
<li><code>6-1</code> 快照分层：增量恢复与执行经济学</li>
<li><code>7-1</code> Register trait 语义下沉：类型系统如何守住 ISA</li>
<li><code>8-1</code> Rust+ASM 混合控制流：快路径与语义锚点协作</li>
</ul>
<h2 id="批次三已完成"><a class="header" href="#批次三已完成">批次三（已完成）</a></h2>
<ul>
<li><code>9-1</code> ISA 选择影响链：从规范开放到治理成本</li>
<li><code>10-1</code> 密码学扩展映射：B/M/A/MOP 的真实分工</li>
<li><code>11-1</code> 收益-成本矩阵：架构决策中的硬约束</li>
<li><code>A-1</code> 密码学执行栈：算法层到计费层的闭环</li>
<li><code>C-1</code> ISA 到协议治理链：扩展引入与回滚策略</li>
</ul>
<h2 id="批次四可选增强"><a class="header" href="#批次四可选增强">批次四（可选增强）</a></h2>
<ul>
<li>图示对应的“实验脚本化”版本（每篇附可复现实验）</li>
<li>图示对应的“审计报告模板化”版本（每篇附审计表）</li>
<li>图示对应的“教学演示版”版本（面向培训场景）</li>
</ul>
<h2 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h2>
<ul>
<li>入门建议：按批次顺序阅读。</li>
<li>评审建议：先读对应章节，再读同编号长文。</li>
<li>工程建议：把每篇长文的“审计清单”直接挂到 PR 模板。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-1-1-长文共识-vm-约束层级不是示意图而是设计宪法"><a class="header" href="#图-1-1-长文共识-vm-约束层级不是示意图而是设计宪法">图 1-1 长文：共识 VM 约束层级不是示意图，而是设计宪法</a></h1>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>“协议约束 -&gt; 经济约束 -&gt; 工程约束 -&gt; 执行优化”这四层关系，不是讲解时的教学美化，而是区块链 VM 的实际设计顺序。</p>
<p>只要顺序倒置（例如先追求峰值性能，再补确定性），系统就会在边界输入、计费公平和升级兼容上出现不可控风险。</p>
<h2 id="1-原图重述"><a class="header" href="#1-原图重述">1. 原图重述</a></h2>
<p>图 1-1 的四层结构是：</p>
<pre><code class="language-text">协议约束(可验证/可回放)
经济约束(可计费/抗 DoS)
工程约束(可维护/可审计)
执行优化(Trace/ASM/MOP)
</code></pre>
<p>注意：这是“约束优先级”，不是“模块分层图”。</p>
<h2 id="2-第一层协议约束最上层"><a class="header" href="#2-第一层协议约束最上层">2. 第一层：协议约束（最上层）</a></h2>
<p>协议层关心的是“全网一致”，不是单机正确。它要求 VM 满足：</p>
<ul>
<li>同输入下，状态迁移一致</li>
<li>错误触发条件一致</li>
<li>恢复与重放结果一致</li>
</ul>
<p>在 <code>ckb-vm</code> 中，这种要求落在可定位代码上：</p>
<ul>
<li>结构化错误：<code>src/error.rs</code></li>
<li>版本门控：<code>src/machine/mod.rs</code> <code>VERSION0/1/2</code></li>
<li>执行主循环：<code>run_with_decoder</code></li>
</ul>
<p>任何优化若破坏上述一致性，都属于协议级故障。</p>
<h2 id="3-第二层经济约束可定价"><a class="header" href="#3-第二层经济约束可定价">3. 第二层：经济约束（可定价）</a></h2>
<p>共识系统的 DoS 防线不是“节点跑更快”，而是“攻击者付得起吗”。</p>
<p><code>SupportMachine::add_cycles</code> 的意义在于把执行与预算绑定：</p>
<ul>
<li>超上限：<code>CyclesExceeded</code></li>
<li>溢出：<code>CyclesOverflow</code></li>
</ul>
<p>这使资源消耗从实现细节变成协议可观察量。没有这一层，性能优化会被攻击者反向利用。</p>
<h2 id="4-第三层工程约束可维护"><a class="header" href="#4-第三层工程约束可维护">4. 第三层：工程约束（可维护）</a></h2>
<p>即使语义正确、计费正确，如果工程上不可审计，系统仍会在中长期失控。常见症状：</p>
<ul>
<li>边界语义散落在多个后端</li>
<li>版本升级难以证明兼容</li>
<li>回归问题无法快速归因</li>
</ul>
<p><code>ckb-vm</code> 的有效做法是把关键边界集中在“少数可审阅接口”中：</p>
<ul>
<li><code>Machine/CoreMachine/SupportMachine</code> trait 边界</li>
<li><code>Memory</code> 与 <code>WXorXMemory</code> 权限边界</li>
<li><code>Syscalls</code> 宿主注入边界</li>
</ul>
<h2 id="5-第四层执行优化最后谈"><a class="header" href="#5-第四层执行优化最后谈">5. 第四层：执行优化（最后谈）</a></h2>
<p>Trace、MOP、ASM 都重要，但它们只有在前三层稳定后才安全。</p>
<p>错误的做法是“先上快路径，再找语义解释”；正确做法是“先有语义锚点，再做快路径外包”。</p>
<p>这就是为什么 <code>ckb-vm</code> 保留 Rust 语义主线，并允许 ASM 在 <code>RET_SLOWPATH</code> 回退。</p>
<h2 id="6-反例推演层级倒置会发生什么"><a class="header" href="#6-反例推演层级倒置会发生什么">6. 反例推演：层级倒置会发生什么</a></h2>
<h3 id="场景-a先优化后计费"><a class="header" href="#场景-a先优化后计费">场景 A：先优化后计费</a></h3>
<ul>
<li>结果：热点路径被低估，攻击交易成本下降</li>
<li>后果：出现经济性 DoS 窗口</li>
</ul>
<h3 id="场景-b先优化后版本治理"><a class="header" href="#场景-b先优化后版本治理">场景 B：先优化后版本治理</a></h3>
<ul>
<li>结果：新老版本边界行为漂移</li>
<li>后果：历史交易重放不稳定</li>
</ul>
<h3 id="场景-c先优化后审计收敛"><a class="header" href="#场景-c先优化后审计收敛">场景 C：先优化后审计收敛</a></h3>
<ul>
<li>结果：问题定位依赖“实现者记忆”</li>
<li>后果：线上故障恢复时间不可控</li>
</ul>
<h2 id="7-从图到审计最小检查表"><a class="header" href="#7-从图到审计最小检查表">7. 从图到审计：最小检查表</a></h2>
<ol>
<li>本改动是否影响错误码映射？</li>
<li>本改动是否影响 cycles 累积或上限触发？</li>
<li>本改动是否引入新的宿主隐式依赖？</li>
<li>本改动是否跨版本保持可回放？</li>
</ol>
<p>这四问可以直接作为 PR 门禁。</p>
<h2 id="8-与主文映射"><a class="header" href="#8-与主文映射">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 1 章</code></li>
<li>关键代码：<code>src/machine/mod.rs</code>, <code>src/error.rs</code>, <code>src/cost_model.rs</code></li>
<li>关联附录：<code>附录 E</code>（出版规范）、<code>附录 F</code>（密码学 PR 审计模板）</li>
</ul>
<h2 id="9-一针见血结论"><a class="header" href="#9-一针见血结论">9. 一针见血结论</a></h2>
<p>图 1-1 的价值不在“解释清楚”，而在“强制设计顺序”：先守共识，再谈性能。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-2-1-长文从-run-到-exit-的生命周期为什么必须做成显式状态机"><a class="header" href="#图-2-1-长文从-run-到-exit-的生命周期为什么必须做成显式状态机">图 2-1 长文：从 run 到 exit 的生命周期，为什么必须做成显式状态机</a></h1>
<h2 id="摘要-1"><a class="header" href="#摘要-1">摘要</a></h2>
<p>“run_with_memory -&gt; load_program -&gt; run -&gt; exit_code”看起来是一条普通流程，但在共识 VM 中，它必须是可审计状态机：</p>
<ul>
<li>每个状态可命名</li>
<li>每个转移可验证</li>
<li>每个失败可复现</li>
</ul>
<p>否则线上问题无法做确定归因。</p>
<h2 id="1-原图再定义从流程图到状态图"><a class="header" href="#1-原图再定义从流程图到状态图">1. 原图再定义：从流程图到状态图</a></h2>
<p>图 2-1 可重写为七态模型：</p>
<ol>
<li><code>Created</code></li>
<li><code>LoadedELF</code></li>
<li><code>StackReady</code></li>
<li><code>Running</code></li>
<li><code>Trapped</code></li>
<li><code>Exited</code></li>
<li><code>Errored</code></li>
</ol>
<p>其中 <code>Running &lt;-&gt; Trapped</code> 可循环，其余转移应单向、可解释。</p>
<h2 id="2-装载阶段为什么不能顺手做掉"><a class="header" href="#2-装载阶段为什么不能顺手做掉">2. 装载阶段为什么不能“顺手做掉”</a></h2>
<p><code>load_program</code> 在 <code>ckb-vm</code> 里被拆成：</p>
<ul>
<li><code>load_elf</code>：映像写入和入口设置</li>
<li><code>initialize</code>：syscall/debugger 初始化 + 栈准备</li>
</ul>
<p>这种拆分意义很大：</p>
<ul>
<li>装载失败与执行失败语义可区分</li>
<li>栈 ABI 错误可单独归因</li>
<li>快照/恢复可插入明确节点</li>
</ul>
<h2 id="3-运行循环的三道闸门"><a class="header" href="#3-运行循环的三道闸门">3. 运行循环的三道闸门</a></h2>
<p><code>run_with_decoder</code> 每轮至少检查：</p>
<ol>
<li><code>pause</code> 中断</li>
<li><code>reset_signal</code> 缓存失效</li>
<li><code>step</code> 的 decode/execute/cycles</li>
</ol>
<p>这三道闸门把“可中断、可重置、可计费”变成主循环固有属性，而不是外围临时逻辑。</p>
<h2 id="4-失败语义为什么要结构化"><a class="header" href="#4-失败语义为什么要结构化">4. 失败语义为什么要结构化</a></h2>
<p>如果运行失败只返回文本字符串，跨节点、跨后端就很难稳定比较。</p>
<p><code>Error</code> 枚举的工程价值在于：</p>
<ul>
<li>每类失败都有固定语义</li>
<li>可用于差分测试和发布门禁</li>
<li>可与版本兼容策略绑定</li>
</ul>
<p>这也是“故障可治理”的前提。</p>
<h2 id="5-ecall-的内核最小闭环"><a class="header" href="#5-ecall-的内核最小闭环">5. <code>ecall</code> 的内核最小闭环</a></h2>
<p><code>Machine::ecall</code> 默认内建仅 <code>93</code>（退出），其余交外部 <code>Syscalls</code>。</p>
<p>这是非常关键的架构选择：</p>
<ul>
<li>内核保留最小闭环能力</li>
<li>宿主能力显式注入</li>
<li>共识边界不被宿主细节污染</li>
</ul>
<h2 id="6-实战示例一次最小退出路径"><a class="header" href="#6-实战示例一次最小退出路径">6. 实战示例：一次最小退出路径</a></h2>
<p>可观测序列通常是：</p>
<ul>
<li><code>A7 &lt;- 93</code></li>
<li><code>A0 &lt;- exit_code</code></li>
<li><code>ecall</code></li>
<li><code>set_running(false)</code></li>
<li><code>run()</code> 返回 <code>exit_code</code></li>
</ul>
<p>如果某后端在此路径上行为不同，差分测试应立即报警。</p>
<h2 id="7-审计与运维视角"><a class="header" href="#7-审计与运维视角">7. 审计与运维视角</a></h2>
<h3 id="审计要点"><a class="header" href="#审计要点">审计要点</a></h3>
<ul>
<li>是否存在未命名的隐式状态转移？</li>
<li>是否存在异常路径跳过计费检查？</li>
<li>是否存在 reset 后缓存未失效风险？</li>
</ul>
<h3 id="运维要点"><a class="header" href="#运维要点">运维要点</a></h3>
<ul>
<li>失败是否可由错误码直接归类？</li>
<li>快照恢复是否可定位到状态节点？</li>
</ul>
<h2 id="8-与主文映射-1"><a class="header" href="#8-与主文映射-1">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 2 章</code></li>
<li>关键代码：<code>src/lib.rs</code>, <code>src/machine/mod.rs</code></li>
<li>关联附录：<code>附录 D</code> 术语交叉索引</li>
</ul>
<h2 id="9-一针见血结论-1"><a class="header" href="#9-一针见血结论-1">9. 一针见血结论</a></h2>
<p>生命周期设计不是“流程顺手写出来”，而是共识系统的控制平面，必须显式、可检验、可回放。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-3-1-长文elf-到页动作的转换为什么这是-vm-的第一道安全防线"><a class="header" href="#图-3-1-长文elf-到页动作的转换为什么这是-vm-的第一道安全防线">图 3-1 长文：ELF 到页动作的转换，为什么这是 VM 的第一道安全防线</a></h1>
<h2 id="摘要-2"><a class="header" href="#摘要-2">摘要</a></h2>
<p>很多工程把“装载器”当成输入解析器，但在区块链 VM 里，装载器实际上是“安全语义编译器”：</p>
<ul>
<li>把外部 ELF 翻译成受控内存状态</li>
<li>把权限策略固化为页级规则</li>
<li>把非法输入转换为确定错误</li>
</ul>
<h2 id="1-从二进制文件到-programmetadata"><a class="header" href="#1-从二进制文件到-programmetadata">1. 从二进制文件到 <code>ProgramMetadata</code></a></h2>
<p><code>parse_elf</code> 的关键产物不是“解析成功”，而是 <code>ProgramMetadata</code>：</p>
<ul>
<li><code>actions[]</code>：每个页动作的地址、大小、权限、数据切片、偏移</li>
<li><code>entry</code>：入口地址</li>
</ul>
<p>这意味着“装载行为”本身可以被缓存、复核、重放。</p>
<h2 id="2-权限映射不是建议是硬拒绝"><a class="header" href="#2-权限映射不是建议是硬拒绝">2. 权限映射不是建议，是硬拒绝</a></h2>
<p><code>convert_flags</code> 的两个强拒绝非常关键：</p>
<ul>
<li>不可读段直接拒绝</li>
<li>可写且可执行段直接拒绝</li>
</ul>
<p>随后 <code>WXorXMemory</code> 在运行期继续执行页权限检查，实现“装载期 + 执行期”双保险。</p>
<h2 id="3-为什么要做双阶段权限控制"><a class="header" href="#3-为什么要做双阶段权限控制">3. 为什么要做双阶段权限控制</a></h2>
<p>只在装载期做权限判断不够，因为运行期仍可能发生：</p>
<ul>
<li>越权写入</li>
<li>边界跨页误写</li>
<li>历史页状态污染</li>
</ul>
<p>只在运行期检查也不够，因为非法映像会在更早阶段放大风险。</p>
<p>两者组合才是安全闭环。</p>
<h2 id="4-边界问题的真实难点"><a class="header" href="#4-边界问题的真实难点">4. 边界问题的真实难点</a></h2>
<p>装载器最容易出错的不是主路径，而是边界组合：</p>
<ul>
<li><code>offset + filesz</code> 越界</li>
<li><code>size/page align</code> 不一致</li>
<li><code>offset_from_addr</code> 与页内填充冲突</li>
</ul>
<p><code>ckb-vm</code> 在 <code>parse_elf</code> 和 <code>WXorXMemory::init_pages</code> 对这些条件有显式拒绝路径，这是工程成熟度的重要信号。</p>
<h2 id="5-栈初始化为什么也属于装载安全"><a class="header" href="#5-栈初始化为什么也属于装载安全">5. 栈初始化为什么也属于装载安全</a></h2>
<p>在共识系统里，栈布局不是 ABI 小事。<code>initialize_stack</code> 涉及：</p>
<ul>
<li>对齐策略</li>
<li><code>argc/argv</code> 结构</li>
<li>版本兼容行为</li>
</ul>
<p>任何栈初始化差异都可能在合约入口阶段放大成跨节点行为差异。</p>
<h2 id="6-审计模型把装载器当作状态转换器"><a class="header" href="#6-审计模型把装载器当作状态转换器">6. 审计模型：把装载器当作“状态转换器”</a></h2>
<p>推荐用“三段式审计”：</p>
<ol>
<li>输入合法性：ELF 字段与切片边界</li>
<li>转换正确性：action 序列是否符合权限规则</li>
<li>结果可验证：页标志与入口状态是否可重算</li>
</ol>
<p>这比“看代码是否优雅”更有效。</p>
<h2 id="7-读者实验建议"><a class="header" href="#7-读者实验建议">7. 读者实验建议</a></h2>
<p>做一个最小实验：</p>
<ul>
<li>构造一个 <code>W+X</code> 段 ELF</li>
<li>观察装载阶段错误是否稳定</li>
<li>在 Rust 与 ASM 路径对拍错误码</li>
</ul>
<p>这个实验能快速验证“装载防线”是否真实有效。</p>
<h2 id="8-与主文映射-2"><a class="header" href="#8-与主文映射-2">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 3 章</code></li>
<li>关键代码：<code>src/elf.rs</code>, <code>src/memory/wxorx.rs</code>, <code>src/machine/mod.rs</code></li>
<li>关联附录：<code>附录 E</code>（规范）、<code>附录 G</code>（改稿清单）</li>
</ul>
<h2 id="9-一针见血结论-2"><a class="header" href="#9-一针见血结论-2">9. 一针见血结论</a></h2>
<p>ELF 装载器不是“把程序读进来”，而是把不可信输入约束为可信执行起点。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-4-1-长文取指与解码快路径如何在确定性边界内拿到性能"><a class="header" href="#图-4-1-长文取指与解码快路径如何在确定性边界内拿到性能">图 4-1 长文：取指与解码快路径，如何在确定性边界内拿到性能</a></h1>
<h2 id="摘要-3"><a class="header" href="#摘要-3">摘要</a></h2>
<p>共识 VM 的性能优化必须满足一个前提：不改变语义。图 4-1 展示的快路径（页内快速取指、解码缓存、MOP、Trace）本质上是“结构化优化”，不是“语义冒险”。</p>
<h2 id="1-取指快路径为什么先看页边界"><a class="header" href="#1-取指快路径为什么先看页边界">1. 取指快路径：为什么先看页边界</a></h2>
<p><code>decode_bits</code> 分两类路径：</p>
<ul>
<li>非页尾：快速 <code>execute_load32</code></li>
<li>页尾：分段 <code>load16</code>，必要时跨页补读</li>
</ul>
<p>这不是微优化细节，而是正确性条件：</p>
<ul>
<li>不跨页时走快路径降低开销</li>
<li>跨页时走稳路径避免边界读错</li>
</ul>
<h2 id="2-解码缓存命中率与语义稳定"><a class="header" href="#2-解码缓存命中率与语义稳定">2. 解码缓存：命中率与语义稳定</a></h2>
<p><code>instructions_cache</code> 的价值是减少重复 decode，但它必须配套失效规则。</p>
<p>至少要确保：</p>
<ul>
<li>reset 后缓存清空</li>
<li>版本变化不复用旧缓存</li>
<li>代码语义变化时不读陈旧解码</li>
</ul>
<p>缓存命中率永远不该优先于语义正确性。</p>
<h2 id="3-mop-融合把模式压缩不把语义压坏"><a class="header" href="#3-mop-融合把模式压缩不把语义压坏">3. MOP 融合：把模式压缩，不把语义压坏</a></h2>
<p>MOP 的正确定义是“可证明等价的模式融合”。</p>
<p>每条融合规则都应回答三问：</p>
<ol>
<li>融合前后寄存器状态是否一致？</li>
<li>融合前后内存副作用是否一致？</li>
<li>融合前后 PC 前进是否一致？</li>
</ol>
<p>三问不成立，融合就不是优化而是语义分叉源。</p>
<h2 id="4-trace-执行解释器里的局部线程化"><a class="header" href="#4-trace-执行解释器里的局部线程化">4. Trace 执行：解释器里的局部线程化</a></h2>
<p><code>TraceMachine</code> 的策略是缓存 basic block，并预绑定处理函数。收益来源：</p>
<ul>
<li>减少重复 decode</li>
<li>减少分发开销</li>
<li>提高循环体路径稳定性</li>
</ul>
<p>它不追求 JIT 式激进优化，而是以可审计为前提做局部加速。</p>
<h2 id="5-rust-与-asm-的协同边界"><a class="header" href="#5-rust-与-asm-的协同边界">5. Rust 与 ASM 的协同边界</a></h2>
<p>在汇编路径中，<code>RET_SLOWPATH</code> 回退 Rust 执行是关键安全阀：</p>
<ul>
<li>快路径负责吞吐</li>
<li>慢路径负责语义兜底</li>
</ul>
<p>这使优化和正确性形成主从关系，而非相互竞争。</p>
<h2 id="6-性能评估的正确方式"><a class="header" href="#6-性能评估的正确方式">6. 性能评估的正确方式</a></h2>
<p>不建议只看单指令 microbenchmark。更有效的是：</p>
<ul>
<li>真实 workload 下的 cycles 总量</li>
<li>opcode 结构分布</li>
<li>MOP/Trace 命中率</li>
<li>后端差分一致性</li>
</ul>
<p>没有一致性证明的性能收益，在共识系统里没有发布价值。</p>
<h2 id="7-审计清单可直接执行"><a class="header" href="#7-审计清单可直接执行">7. 审计清单（可直接执行）</a></h2>
<ul>
<li>快路径与慢路径是否覆盖同一语义空间</li>
<li>缓存失效是否与 reset/version 联动</li>
<li>融合规则是否有反例测试</li>
<li>跨页取指是否有专门边界向量</li>
</ul>
<h2 id="8-与主文映射-3"><a class="header" href="#8-与主文映射-3">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 4 章</code></li>
<li>关键代码：<code>src/decoder.rs</code>, <code>src/machine/trace.rs</code>, <code>src/instructions/execute.rs</code></li>
<li>关联附录：<code>附录 F</code>（审计模板）、<code>附录 H/I</code>（端到端案例）</li>
</ul>
<h2 id="9-一针见血结论-3"><a class="header" href="#9-一针见血结论-3">9. 一针见血结论</a></h2>
<p>在共识 VM 中，真正有价值的性能优化不是“跑得最猛”，而是“快且可证明”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-5-1-长文ecall-分发路径如何把宿主能力关进最小边界"><a class="header" href="#图-5-1-长文ecall-分发路径如何把宿主能力关进最小边界">图 5-1 长文：ecall 分发路径，如何把宿主能力关进最小边界</a></h1>
<h2 id="摘要-4"><a class="header" href="#摘要-4">摘要</a></h2>
<p><code>ecall</code> 在区块链 VM 中不是“调用系统 API”的便捷入口，而是共识安全边界。图 5-1 的分发路径揭示了一个核心原则：</p>
<ul>
<li>内核只保留最小可验证语义</li>
<li>宿主能力必须显式注入</li>
<li>无处理能力时必须稳定失败</li>
</ul>
<p>这三点共同决定了 Trusted Computing Base（TCB）的大小。</p>
<h2 id="1-原图重述从-guest-指令到宿主处理"><a class="header" href="#1-原图重述从-guest-指令到宿主处理">1. 原图重述：从 guest 指令到宿主处理</a></h2>
<p>图 5-1 可抽象为以下链路：</p>
<pre><code class="language-text">guest ecall
  -&gt; Machine::ecall
     -&gt; if A7 == 93: exit
     -&gt; else: iterate syscall modules
     -&gt; if none handled: InvalidEcall
</code></pre>
<p>注意该路径有两个关键约束：</p>
<ol>
<li><code>A7=93</code> 是内核闭环语义（退出）</li>
<li>其余能力全部外置到 <code>Syscalls</code> 模块</li>
</ol>
<h2 id="2-为什么只内建-exit93"><a class="header" href="#2-为什么只内建-exit93">2. 为什么只内建 <code>exit(93)</code></a></h2>
<p>把退出能力内建有两个现实理由：</p>
<ul>
<li>VM 必须保证“可终止”语义自洽</li>
<li>退出码是执行结果的一部分，不能依赖外部模块存在</li>
</ul>
<p>反过来，如果连退出都外包，系统会出现“没有 syscall 模块就无法稳定终止”的反常状态。</p>
<h2 id="3-插件式-syscall-的安全收益"><a class="header" href="#3-插件式-syscall-的安全收益">3. 插件式 syscall 的安全收益</a></h2>
<p><code>Syscalls</code> trait 的接口很小：<code>initialize</code> 与 <code>ecall</code>。这带来三类收益：</p>
<ol>
<li><strong>审计收敛</strong>：核心 VM 不必内置复杂宿主能力。</li>
<li><strong>部署灵活</strong>：不同场景可挂不同能力集。</li>
<li><strong>失败可控</strong>：未处理 syscall 返回 <code>InvalidEcall</code>，不是静默成功。</li>
</ol>
<p>在共识系统里，“明确失败”比“隐式兼容”更安全。</p>
<h2 id="4-abi-视角为什么-syscall-也要文档化"><a class="header" href="#4-abi-视角为什么-syscall-也要文档化">4. ABI 视角：为什么 syscall 也要文档化</a></h2>
<p>多数系统出问题不是算法错，而是 ABI 漂移：</p>
<ul>
<li>输入寄存器约定改变</li>
<li>输出寄存器未定义</li>
<li>错误码含义模糊</li>
</ul>
<p>建议每个 syscall 都有固定模板：</p>
<ul>
<li>编号（A7）</li>
<li>入参寄存器/内存布局</li>
<li>出参寄存器</li>
<li>错误码</li>
<li>cycles 影响</li>
</ul>
<p>这在多团队协作时尤为关键。</p>
<h2 id="5-常见反模式"><a class="header" href="#5-常见反模式">5. 常见反模式</a></h2>
<h3 id="反模式-a把网络文件系统能力直接塞进-vm-核心"><a class="header" href="#反模式-a把网络文件系统能力直接塞进-vm-核心">反模式 A：把网络/文件系统能力直接塞进 VM 核心</a></h3>
<p>短期看“功能齐全”，长期会导致：</p>
<ul>
<li>TCB 膨胀</li>
<li>宿主差异污染共识语义</li>
<li>审计成本爆炸</li>
</ul>
<h3 id="反模式-b未处理-syscall-返回默认成功"><a class="header" href="#反模式-b未处理-syscall-返回默认成功">反模式 B：未处理 syscall 返回默认成功</a></h3>
<p>这会让“能力不存在”被误判为“执行成功”，是最危险的语义歧义之一。</p>
<h3 id="反模式-c宿主副作用不计费"><a class="header" href="#反模式-c宿主副作用不计费">反模式 C：宿主副作用不计费</a></h3>
<p>若 syscall 消耗大量外部资源但不计入 cycles，会形成经济模型漏洞。</p>
<h2 id="6-审计清单可直接挂-pr"><a class="header" href="#6-审计清单可直接挂-pr">6. 审计清单（可直接挂 PR）</a></h2>
<ol>
<li>新增 syscall 是否附完整 ABI 说明？</li>
<li>未处理路径是否稳定返回 <code>InvalidEcall</code>？</li>
<li>宿主副作用是否有计费或额度边界？</li>
<li>Rust/ASM 后端是否在该 syscall 上行为一致？</li>
<li>禁用该模块后是否保持核心 VM 可运行（至少可退出）？</li>
</ol>
<h2 id="7-与主文映射"><a class="header" href="#7-与主文映射">7. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 5 章</code></li>
<li>关键代码：<code>src/machine/mod.rs</code>, <code>src/syscalls/mod.rs</code>, <code>examples/ckb_vm_runner.rs</code></li>
<li>关联附录：<code>附录 F</code>（密码学 PR 审计模板）</li>
</ul>
<h2 id="8-一针见血结论"><a class="header" href="#8-一针见血结论">8. 一针见血结论</a></h2>
<p>ecall 设计的关键不是“能做多少事”，而是“把宿主能力控制在多小、且仍可验证”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-6-1-长文快照分层不是序列化技巧而是执行经济学核心"><a class="header" href="#图-6-1-长文快照分层不是序列化技巧而是执行经济学核心">图 6-1 长文：快照分层不是序列化技巧，而是执行经济学核心</a></h1>
<h2 id="摘要-5"><a class="header" href="#摘要-5">摘要</a></h2>
<p>图 6-1 展示的“dirty pages + pages_from_source”分层，不只是节省存储空间。它在区块链 VM 中的真正价值是：</p>
<ul>
<li>让长任务可分段支付</li>
<li>让恢复语义可验证</li>
<li>让状态传输成本可预测</li>
</ul>
<p>快照机制本质上是执行层的经济基础设施。</p>
<h2 id="1-原图重述状态分层"><a class="header" href="#1-原图重述状态分层">1. 原图重述：状态分层</a></h2>
<p>图 6-1 的核心结构：</p>
<pre><code class="language-text">VM state
 = registers + pc + cycles + max_cycles + lr
 + memory pages

snapshot v1: dirty pages
snapshot v2: dirty pages + pages_from_source
</code></pre>
<p>这里的关键不是“存什么”，而是“哪些数据可以引用，哪些必须复制”。</p>
<h2 id="2-snapshot-v1-与-v2-的本质差异"><a class="header" href="#2-snapshot-v1-与-v2-的本质差异">2. Snapshot v1 与 v2 的本质差异</a></h2>
<h3 id="v1脏页快照"><a class="header" href="#v1脏页快照">v1（脏页快照）</a></h3>
<ul>
<li>优点：实现简单，语义直观</li>
<li>缺点：对稳定数据重复存储，体积可能偏大</li>
</ul>
<h3 id="v2datasource-分层"><a class="header" href="#v2datasource-分层">v2（DataSource 分层）</a></h3>
<ul>
<li>优点：稳定来源页可引用，减少冗余</li>
<li>缺点：实现复杂，需要维护来源映射一致性</li>
</ul>
<p>当程序页与只读数据占比较高时，v2 往往更有现实收益。</p>
<h2 id="3-恢复正确性的四条不变量"><a class="header" href="#3-恢复正确性的四条不变量">3. 恢复正确性的四条不变量</a></h2>
<p>恢复后应满足：</p>
<ol>
<li><code>pc/registers/cycles/max_cycles</code> 一致</li>
<li>页内容和页标志一致</li>
<li><code>load reservation address</code> 一致</li>
<li>恢复后继续执行结果与不中断执行一致</li>
</ol>
<p>这四条可以视作“快照正确”的最小证明集合。</p>
<h2 id="4-为什么这是经济问题而不仅是工程问题"><a class="header" href="#4-为什么这是经济问题而不仅是工程问题">4. 为什么这是经济问题而不仅是工程问题</a></h2>
<p>链上长任务若必须“一次性跑完”，会出现：</p>
<ul>
<li>用户必须预付高预算</li>
<li>节点需要承受长时间占用</li>
<li>失败重试成本高</li>
</ul>
<p>快照分段执行将其改写为：</p>
<ul>
<li>按阶段支付</li>
<li>可恢复推进</li>
<li>可重放验证</li>
</ul>
<p>这直接提升了执行层的经济可用性。</p>
<h2 id="5-常见失效场景"><a class="header" href="#5-常见失效场景">5. 常见失效场景</a></h2>
<h3 id="场景-a恢复不校验版本"><a class="header" href="#场景-a恢复不校验版本">场景 A：恢复不校验版本</a></h3>
<p>结果：新旧语义混跑，重放结果漂移。</p>
<h3 id="场景-bdirtysource-标记混乱"><a class="header" href="#场景-bdirtysource-标记混乱">场景 B：dirty/source 标记混乱</a></h3>
<p>结果：恢复后页内容与标志不一致，错误具有延迟暴露特征。</p>
<h3 id="场景-c只比最终退出码不比中间状态"><a class="header" href="#场景-c只比最终退出码不比中间状态">场景 C：只比最终退出码，不比中间状态</a></h3>
<p>结果：隐藏寄存器或内存偏差难以及时发现。</p>
<h2 id="6-指标化管理建议"><a class="header" href="#6-指标化管理建议">6. 指标化管理建议</a></h2>
<p>长期记录：</p>
<ul>
<li><code>dirty_pages / total_pages</code></li>
<li><code>pages_from_source / total_pages</code></li>
<li><code>snapshot_size_per_tx</code></li>
<li><code>resume_success_rate</code></li>
</ul>
<p>如果这些指标不可见，快照优化就很容易沦为“感觉变快”。</p>
<h2 id="7-审计清单可执行"><a class="header" href="#7-审计清单可执行">7. 审计清单（可执行）</a></h2>
<ol>
<li>是否强校验快照版本与机器版本一致？</li>
<li>是否验证恢复后继续执行与一次性执行等价？</li>
<li>是否有覆盖跨页、边界、空参数等极端用例？</li>
<li>是否记录并监控快照体积和恢复成功率？</li>
</ol>
<h2 id="8-与主文映射-4"><a class="header" href="#8-与主文映射-4">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 6 章</code></li>
<li>关键代码：<code>src/snapshot.rs</code>, <code>src/snapshot2.rs</code></li>
<li>关联附录：<code>附录 G</code>（作者改稿清单）</li>
</ul>
<h2 id="9-一针见血结论-4"><a class="header" href="#9-一针见血结论-4">9. 一针见血结论</a></h2>
<p>快照分层的真正价值不是“省空间”，而是把链上长计算变成可支付、可恢复、可验证的连续过程。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-7-1-长文register-trait-语义下沉类型系统如何守住-isa-边界"><a class="header" href="#图-7-1-长文register-trait-语义下沉类型系统如何守住-isa-边界">图 7-1 长文：Register trait 语义下沉，类型系统如何守住 ISA 边界</a></h1>
<h2 id="摘要-6"><a class="header" href="#摘要-6">摘要</a></h2>
<p>图 7-1 的关键观点是“语义在 trait，而不是散在指令处理函数里”。在共识 VM 里，这不是抽象偏好，而是防止跨平台语义漂移的核心手段。</p>
<h2 id="1-原图重述语义下沉路径"><a class="header" href="#1-原图重述语义下沉路径">1. 原图重述：语义下沉路径</a></h2>
<p>图 7-1 可以写成：</p>
<pre><code class="language-text">Instruction handlers
  -&gt; Register trait methods
     -&gt; concrete impl (u32/u64)
</code></pre>
<p>目标是把边界行为集中到单点契约，避免“每条指令各写一套边界处理”。</p>
<h2 id="2-为什么这在共识系统里是刚需"><a class="header" href="#2-为什么这在共识系统里是刚需">2. 为什么这在共识系统里是刚需</a></h2>
<p>共识层最怕两种错误：</p>
<ol>
<li>代码崩溃（可观测）</li>
<li>语义不一致（隐蔽且致命）</li>
</ol>
<p>后者尤其危险。若边界语义分散实现，修复一处很容易漏另一处。</p>
<p><code>Register</code> trait 把这些边界显式化：</p>
<ul>
<li>除零行为</li>
<li>溢出行为</li>
<li>有符号/无符号差异</li>
<li>位扩展规则</li>
</ul>
<h2 id="3-x0-不变量的工程意义"><a class="header" href="#3-x0-不变量的工程意义">3. x0 不变量的工程意义</a></h2>
<p><code>update_register</code> 统一处理“x0 不可写”。</p>
<p>这看似小细节，实则是架构不变量守门点：</p>
<ul>
<li>若某路径绕过该函数，可能出现“零寄存器可写”语义偏差</li>
<li>若语义偏差只出现在某后端，就会变成差分 bug</li>
</ul>
<p>因此这种单点不变量非常适合做强制测试。</p>
<h2 id="4-trait-不是银弹仍需合约测试"><a class="header" href="#4-trait-不是银弹仍需合约测试">4. trait 不是银弹：仍需合约测试</a></h2>
<p>有 trait 并不自动正确，典型风险：</p>
<ul>
<li>新方法定义后，某实现语义不完整</li>
<li>优化路径绕开 trait 直接操作原始值</li>
<li>某实现用宿主默认行为替代 ISA 规定行为</li>
</ul>
<p>解决方式是“trait 合约测试”，而不是“编译通过即认为安全”。</p>
<h2 id="5-推荐测试向量"><a class="header" href="#5-推荐测试向量">5. 推荐测试向量</a></h2>
<p>最小向量集应覆盖：</p>
<ul>
<li>除零与 rem/div 特殊值</li>
<li>有符号最小值溢出</li>
<li><code>sign_extend/zero_extend</code> 边界</li>
<li>位旋转、位计数、clmul 类指令</li>
</ul>
<p>并分别在 <code>u32</code> 与 <code>u64</code> 实现上执行。</p>
<h2 id="6-与性能优化的关系"><a class="header" href="#6-与性能优化的关系">6. 与性能优化的关系</a></h2>
<p>语义下沉并不与性能冲突：</p>
<ul>
<li>快路径可以在 trait 语义确定后优化</li>
<li>慢路径可以依赖 trait 做保底</li>
</ul>
<p>这就是“先语义后优化”的工程次序。</p>
<h2 id="7-审计清单实务版"><a class="header" href="#7-审计清单实务版">7. 审计清单（实务版）</a></h2>
<ol>
<li>本 PR 是否触碰 <code>Register</code> trait 行为？</li>
<li>若触碰，是否附带跨位宽合约测试？</li>
<li>是否有路径绕过 <code>update_register</code>？</li>
<li>是否引入依赖宿主 UB/隐式转换的写法？</li>
</ol>
<h2 id="8-与主文映射-5"><a class="header" href="#8-与主文映射-5">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 7 章</code></li>
<li>关键代码：<code>src/instructions/register.rs</code>, <code>src/instructions/utils.rs</code></li>
<li>关联附录：<code>附录 D</code>（术语交叉索引）</li>
</ul>
<h2 id="9-一针见血结论-5"><a class="header" href="#9-一针见血结论-5">9. 一针见血结论</a></h2>
<p>在共识 VM 中，类型系统的核心价值不是“代码优雅”，而是“把语义变成可验证契约”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-8-1-长文rust--asm-混合控制流如何做到快路径服从语义锚点"><a class="header" href="#图-8-1-长文rust--asm-混合控制流如何做到快路径服从语义锚点">图 8-1 长文：Rust + ASM 混合控制流，如何做到“快路径服从语义锚点”</a></h1>
<h2 id="摘要-7"><a class="header" href="#摘要-7">摘要</a></h2>
<p>图 8-1 的核心不是“有汇编就更快”，而是“如何让汇编加速不破坏语义主权”。<code>ckb-vm</code> 的关键做法是：</p>
<ul>
<li>ASM 负责高频执行</li>
<li>Rust 负责状态机解释与错误语义</li>
<li>慢路径可回退到 Rust 保底</li>
</ul>
<p>这是共识系统中非常务实的折中架构。</p>
<h2 id="1-原图重述控制流分工"><a class="header" href="#1-原图重述控制流分工">1. 原图重述：控制流分工</a></h2>
<p>图 8-1 可表达为：</p>
<pre><code class="language-text">ASM execute
  -&gt; RET_* status
     -&gt; Rust dispatcher
        -&gt; ecall/ebreak/slowpath/error mapping
</code></pre>
<p>即“汇编执行 + Rust 控制平面”的二层结构。</p>
<h2 id="2-为什么不能纯汇编到底"><a class="header" href="#2-为什么不能纯汇编到底">2. 为什么不能纯汇编到底</a></h2>
<p>纯汇编的风险不在性能，而在治理：</p>
<ul>
<li>语义文档化成本高</li>
<li>差分定位成本高</li>
<li>新成员维护门槛高</li>
</ul>
<p>在共识系统里，长期可维护性比短期峰值更关键。Rust 作为语义锚点，可以持续承接版本演进与审计。</p>
<h2 id="3-ret_slowpath-的战略价值"><a class="header" href="#3-ret_slowpath-的战略价值">3. <code>RET_SLOWPATH</code> 的战略价值</a></h2>
<p><code>RET_SLOWPATH</code> 并不是“性能不足时的临时补丁”，而是架构安全阀：</p>
<ul>
<li>快路径未覆盖场景可回退</li>
<li>新语义可先在 Rust 落地</li>
<li>汇编后续按优先级补齐</li>
</ul>
<p>这让系统具备“可增量优化、可持续正确”的演进能力。</p>
<h2 id="4-双后端一致性是主成本"><a class="header" href="#4-双后端一致性是主成本">4. 双后端一致性是主成本</a></h2>
<p>混合架构最大成本是一致性维护，主要体现在：</p>
<ul>
<li>新 opcode 要双实现</li>
<li>语义修复要双同步</li>
<li>边界行为要双验证</li>
</ul>
<p>因此必须有常态化差分流水线，否则会积累“潜在分叉债务”。</p>
<h2 id="5-推荐差分矩阵"><a class="header" href="#5-推荐差分矩阵">5. 推荐差分矩阵</a></h2>
<p>最小矩阵建议：</p>
<ul>
<li>后端：Rust / ASM</li>
<li>输入：正常 / 边界 / 恶意</li>
<li>指标：exit_code / cycles / reg_digest / mem_digest</li>
</ul>
<p>任何差异都应阻断合并并自动归档。</p>
<h2 id="6-发布策略建议"><a class="header" href="#6-发布策略建议">6. 发布策略建议</a></h2>
<p>建议采用“语义先行”策略：</p>
<ol>
<li>Rust 先落语义</li>
<li>测试先证明等价</li>
<li>ASM 再做热点加速</li>
</ol>
<p>若顺序反过来，往往会把优化问题升级成共识风险。</p>
<h2 id="7-审计清单"><a class="header" href="#7-审计清单">7. 审计清单</a></h2>
<ol>
<li>新增 <code>RET_*</code> 是否有完整处理映射？</li>
<li>slowpath 回退是否覆盖未实现 opcode？</li>
<li>Rust/ASM 是否有同版本同输入差分报告？</li>
<li>构建矩阵是否明确平台支持与禁用策略？</li>
</ol>
<h2 id="8-与主文映射-6"><a class="header" href="#8-与主文映射-6">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 8 章</code></li>
<li>关键代码：<code>build.rs</code>, <code>src/machine/asm/mod.rs</code>, <code>src/machine/asm/traces.rs</code></li>
<li>关联附录：<code>附录 C</code>（RISC-V 治理）、<code>附录 F</code>（审计模板）</li>
</ul>
<h2 id="9-一针见血结论-6"><a class="header" href="#9-一针见血结论-6">9. 一针见血结论</a></h2>
<p>混合架构的正确打开方式不是“把语义交给汇编”，而是“让汇编在 Rust 语义边界内加速”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-9-1-长文isa-选择影响链不是性能偏好而是治理架构"><a class="header" href="#图-9-1-长文isa-选择影响链不是性能偏好而是治理架构">图 9-1 长文：ISA 选择影响链，不是性能偏好而是治理架构</a></h1>
<h2 id="摘要-8"><a class="header" href="#摘要-8">摘要</a></h2>
<p>图 9-1 表示“ISA -&gt; 工具链 -&gt; 实现一致性 -&gt; 升级治理”的影响链。它告诉我们：在区块链 VM 中，ISA 不是底层实现细节，而是协议长期可维护性的起点。</p>
<h2 id="1-原图重述-1"><a class="header" href="#1-原图重述-1">1. 原图重述</a></h2>
<pre><code class="language-text">ISA selection
  -&gt; compiler/toolchain
  -&gt; contract ecosystem
  -&gt; verifier/auditor cost
  -&gt; protocol upgrade governance
</code></pre>
<p>该图的含义是“因果链”，不是“并列因素”。</p>
<h2 id="2-为什么共识系统对-isa-更敏感"><a class="header" href="#2-为什么共识系统对-isa-更敏感">2. 为什么共识系统对 ISA 更敏感</a></h2>
<p>传统应用可接受局部平台差异，但共识系统不行。ISA 一旦确定，就会持续影响：</p>
<ul>
<li>合约编译产物一致性</li>
<li>多后端执行一致性</li>
<li>审计工具与测试向量体系</li>
<li>版本升级与回滚复杂度</li>
</ul>
<p>换句话说，ISA 选型错误会在多年后以治理成本形式显现。</p>
<h2 id="3-risc-v-在这条链上的优势"><a class="header" href="#3-risc-v-在这条链上的优势">3. RISC-V 在这条链上的优势</a></h2>
<p>RISC-V 的工程优势不只“开放”二字，而是三件事同时成立：</p>
<ol>
<li>规范公开，便于多实现对拍</li>
<li>编码规整，便于解码和形式化分析</li>
<li>工具链生态稳定，便于长期维护</li>
</ol>
<p>在 <code>ckb-vm</code> 中，这体现在 <code>IMC/B/A/MOP</code> 的组合可逐步演进，而不必推翻已有执行框架。</p>
<h2 id="4-工具链可复现是治理能力的一部分"><a class="header" href="#4-工具链可复现是治理能力的一部分">4. 工具链可复现是治理能力的一部分</a></h2>
<p>若同版本源代码在不同环境编译产物不同，审计就会失效。建议固定并记录：</p>
<ul>
<li>编译器版本</li>
<li>目标三元组与 ISA 标志</li>
<li>链接参数</li>
<li>产物哈希</li>
</ul>
<p>这不是构建细节，而是协议证据链的一部分。</p>
<h2 id="5-反模式以短期-benchmark-决定-isa"><a class="header" href="#5-反模式以短期-benchmark-决定-isa">5. 反模式：以短期 benchmark 决定 ISA</a></h2>
<p>仅用单机性能做决策，常见后果：</p>
<ul>
<li>长期工具链维护成本被低估</li>
<li>多实现对拍成本被忽略</li>
<li>升级时回滚路径缺失</li>
</ul>
<p>这类问题在第一年不明显，但在第三年会成为主成本。</p>
<h2 id="6-审计清单"><a class="header" href="#6-审计清单">6. 审计清单</a></h2>
<ol>
<li>当前 ISA 子集是否有明确规范边界？</li>
<li>是否存在可复现构建流程与产物记录？</li>
<li>多后端是否有同输入一致性对拍？</li>
<li>新扩展引入是否附版本门禁与回滚预案？</li>
</ol>
<h2 id="7-与主文映射-1"><a class="header" href="#7-与主文映射-1">7. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 9 章</code></li>
<li>关键代码：<code>src/lib.rs</code>, <code>src/decoder.rs</code>, <code>build.rs</code></li>
<li>关联附录：<code>附录 C</code>（扩展治理路线）</li>
</ul>
<h2 id="8-一针见血结论-1"><a class="header" href="#8-一针见血结论-1">8. 一针见血结论</a></h2>
<p>ISA 选择在共识系统里的本质，不是“跑更快”，而是“能否在十年尺度内保持可治理”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-10-1-长文密码学扩展映射bmamop-的真实分工"><a class="header" href="#图-10-1-长文密码学扩展映射bmamop-的真实分工">图 10-1 长文：密码学扩展映射，B/M/A/MOP 的真实分工</a></h1>
<h2 id="摘要-9"><a class="header" href="#摘要-9">摘要</a></h2>
<p>图 10-1 把“密码学操作模式”映射到“ISA 扩展与执行机制”。这张图最重要的价值，是避免工程团队掉进“单指令优化神话”：</p>
<ul>
<li>真正的瓶颈通常在操作链，不在单条指令</li>
<li>真正的收益来自结构化压缩，不是局部跑分</li>
</ul>
<h2 id="1-原图重述-2"><a class="header" href="#1-原图重述-2">1. 原图重述</a></h2>
<pre><code class="language-text">Big-int mul/div chain -&gt; M + MOP
Bit permutation       -&gt; B
Carry-less arithmetic -&gt; B
Atomic handshakes     -&gt; A
</code></pre>
<p>需要强调：A 在密码学主路径通常不是热点，但在语义完整性上仍有价值。</p>
<h2 id="2-secp256k1-路径的现实瓶颈"><a class="header" href="#2-secp256k1-路径的现实瓶颈">2. secp256k1 路径的现实瓶颈</a></h2>
<p>在验签路径里，常见热点是：</p>
<ul>
<li>大整数乘加与约简链</li>
<li>进位传播</li>
<li>条件选择与状态搬运</li>
</ul>
<p>这解释了为什么 <code>WIDE_MUL/WIDE_DIV/ADD3*</code> 这类融合操作具有现实价值。</p>
<h2 id="3-哈希路径的现实瓶颈"><a class="header" href="#3-哈希路径的现实瓶颈">3. 哈希路径的现实瓶颈</a></h2>
<p>哈希路径通常表现为：</p>
<ul>
<li>rotate/xor/shift 高频出现</li>
<li>循环体稳定且重复</li>
<li>小块数据访存频繁</li>
</ul>
<p>因此 B 扩展 + Trace 的组合往往收益更明显。</p>
<h2 id="4-mop-的正确定位"><a class="header" href="#4-mop-的正确定位">4. MOP 的正确定位</a></h2>
<p>MOP 不是“改 ISA”，而是“在既有语义上做模式融合”。</p>
<p>只有当以下条件都成立时，MOP 才有发布价值：</p>
<ol>
<li>语义等价可证明</li>
<li>边界行为一致</li>
<li>计费模型可校准</li>
</ol>
<p>否则它会从优化手段变成分叉风险。</p>
<h2 id="5-计费校准为什么与安全绑定"><a class="header" href="#5-计费校准为什么与安全绑定">5. 计费校准为什么与安全绑定</a></h2>
<p>计费偏差不是体验问题，而是安全问题：</p>
<ul>
<li>低估热点路径 -&gt; DoS 经济窗口</li>
<li>高估常用路径 -&gt; 正常用户过度付费</li>
</ul>
<p>所以优化 PR 必须附“性能报告 + 计费报告 + 等价报告”三件套。</p>
<h2 id="6-常见误判"><a class="header" href="#6-常见误判">6. 常见误判</a></h2>
<h3 id="误判-a微基准提升--链上收益提升"><a class="header" href="#误判-a微基准提升--链上收益提升">误判 A：微基准提升 = 链上收益提升</a></h3>
<p>实际上，真实 workload 的控制流与数据分布常与微基准不同。</p>
<h3 id="误判-b平均值更快--系统更安全"><a class="header" href="#误判-b平均值更快--系统更安全">误判 B：平均值更快 = 系统更安全</a></h3>
<p>长尾交易和恶意输入通常决定风险上界。</p>
<h3 id="误判-c确定性通过--恒时安全通过"><a class="header" href="#误判-c确定性通过--恒时安全通过">误判 C：确定性通过 = 恒时安全通过</a></h3>
<p>两者不是同一个问题。</p>
<h2 id="7-审计清单-1"><a class="header" href="#7-审计清单-1">7. 审计清单</a></h2>
<ol>
<li>是否覆盖 secp/hash/Merkle 三类代表性 workload？</li>
<li>MOP 融合是否有前后状态等价报告？</li>
<li>cycles 参数是否有版本化校准记录？</li>
<li>是否单独评估侧信道风险？</li>
</ol>
<h2 id="8-与主文映射-7"><a class="header" href="#8-与主文映射-7">8. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 10 章</code></li>
<li>关键代码：<code>src/instructions/b.rs</code>, <code>src/decoder.rs</code>, <code>src/instructions/execute.rs</code>, <code>src/cost_model.rs</code></li>
<li>关联附录：<code>附录 A</code>, <code>附录 F</code>, <code>附录 H/I</code></li>
</ul>
<h2 id="9-一针见血结论-7"><a class="header" href="#9-一针见血结论-7">9. 一针见血结论</a></h2>
<p>密码学优化最该优化的不是“某条指令”，而是“高频算子链在可验证前提下的整体成本”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-11-1-长文收益-成本矩阵架构决策如何避免单边乐观"><a class="header" href="#图-11-1-长文收益-成本矩阵架构决策如何避免单边乐观">图 11-1 长文：收益-成本矩阵，架构决策如何避免“单边乐观”</a></h1>
<h2 id="摘要-10"><a class="header" href="#摘要-10">摘要</a></h2>
<p>图 11-1 的价值在于把“技术亮点”与“长期成本”放进同一张表。它迫使我们承认：区块链 VM 架构没有免费午餐，所有收益都对应维护负债。</p>
<h2 id="1-原图重述-3"><a class="header" href="#1-原图重述-3">1. 原图重述</a></h2>
<pre><code class="language-text">收益侧: 可验证执行 / 权限边界 / 可恢复执行 / 渐进优化
成本侧: 双后端一致性 / 计费校准 / 宿主集成复杂 / 侧信道审计
</code></pre>
<p>关键点：收益与成本应成对评估，不能只看一边。</p>
<h2 id="2-四个收益不是口号"><a class="header" href="#2-四个收益不是口号">2. 四个收益不是口号</a></h2>
<ol>
<li><strong>可验证执行</strong>：错误语义结构化，可对拍</li>
<li><strong>权限边界清晰</strong>：W^X 与页标志规则稳定</li>
<li><strong>可恢复执行</strong>：快照机制支持分段推进</li>
<li><strong>渐进优化能力</strong>：Rust 语义锚点 + ASM 快路径</li>
</ol>
<p>这些收益都能映射到具体代码与测试机制，不是抽象愿景。</p>
<h2 id="3-四个成本不能回避"><a class="header" href="#3-四个成本不能回避">3. 四个成本不能回避</a></h2>
<ol>
<li><strong>双后端一致性成本</strong>：每次语义变更都要双实现/双验证</li>
<li><strong>计费模型校准成本</strong>：需持续对齐真实 workload</li>
<li><strong>宿主边界集成成本</strong>：能力越多，边界治理越难</li>
<li><strong>侧信道审计成本</strong>：确定性不等于恒时安全</li>
</ol>
<p>架构成熟不是“消除成本”，而是“持续可管理成本”。</p>
<h2 id="4-决策误区"><a class="header" href="#4-决策误区">4. 决策误区</a></h2>
<h3 id="误区-a只要性能提升就值得上线"><a class="header" href="#误区-a只要性能提升就值得上线">误区 A：只要性能提升就值得上线</a></h3>
<p>在共识系统，语义风险权重通常高于性能收益。</p>
<h3 id="误区-b问题以后再补测试"><a class="header" href="#误区-b问题以后再补测试">误区 B：问题以后再补测试</a></h3>
<p>后补测试往往追不上语义漂移速度。</p>
<h3 id="误区-c只看单次上线不看升级链路"><a class="header" href="#误区-c只看单次上线不看升级链路">误区 C：只看单次上线，不看升级链路</a></h3>
<p>没有回滚预案的优化，都是潜在治理事故。</p>
<h2 id="5-可执行决策模型"><a class="header" href="#5-可执行决策模型">5. 可执行决策模型</a></h2>
<p>建议每次重大改动都给出三表：</p>
<ol>
<li>语义影响表（可能改变哪些状态映射）</li>
<li>经济影响表（cycles/费用曲线变化）</li>
<li>治理影响表（升级、回滚、监控计划）</li>
</ol>
<p>三表缺一，不应进入发布候选。</p>
<h2 id="6-指标体系建议"><a class="header" href="#6-指标体系建议">6. 指标体系建议</a></h2>
<p>长期追踪指标：</p>
<ul>
<li>后端差分失败率</li>
<li>cycles 漂移率</li>
<li>兼容回归率</li>
<li>审计问题密度</li>
</ul>
<p>指标的意义在于把“经验争论”转化为“数据对话”。</p>
<h2 id="7-与主文映射-2"><a class="header" href="#7-与主文映射-2">7. 与主文映射</a></h2>
<ul>
<li>对应章节：<code>第 11 章</code></li>
<li>关键代码：<code>src/machine/mod.rs</code>, <code>src/memory/wxorx.rs</code>, <code>src/cost_model.rs</code>, <code>src/machine/asm/mod.rs</code></li>
<li>关联附录：<code>附录 E</code>, <code>附录 G</code></li>
</ul>
<h2 id="8-一针见血结论-2"><a class="header" href="#8-一针见血结论-2">8. 一针见血结论</a></h2>
<p>架构决策的专业性，不体现在“承诺更多收益”，而体现在“明确承担哪些成本并给出治理机制”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-a-1-长文密码学执行栈闭环为什么必须从算法层写到计费层"><a class="header" href="#图-a-1-长文密码学执行栈闭环为什么必须从算法层写到计费层">图 A-1 长文：密码学执行栈闭环，为什么必须从算法层写到计费层</a></h1>
<h2 id="摘要-11"><a class="header" href="#摘要-11">摘要</a></h2>
<p>图 A-1 不是知识图谱，而是执行闭环图：</p>
<ul>
<li>算法层决定算子结构</li>
<li>算子层决定指令分布</li>
<li>指令层决定执行器行为</li>
<li>执行层决定计费现实</li>
</ul>
<p>只优化其中一层，通常会把问题转移到另一层。</p>
<h2 id="1-原图重述-4"><a class="header" href="#1-原图重述-4">1. 原图重述</a></h2>
<pre><code class="language-text">算法层 -&gt; 算子层 -&gt; 指令层 -&gt; 执行层 -&gt; 计费层
</code></pre>
<p>这条链的核心是“闭环”：任何一层改动都应反馈到计费与安全评估。</p>
<h2 id="2-算法层与算子层"><a class="header" href="#2-算法层与算子层">2. 算法层与算子层</a></h2>
<p>算法实现的选择会改变算子谱：</p>
<ul>
<li>大整数实现方式影响乘加链密度</li>
<li>哈希轮函数实现方式影响位操作密度</li>
</ul>
<p>如果团队不先做算子画像，就很容易做错优化优先级。</p>
<h2 id="3-指令层与执行层"><a class="header" href="#3-指令层与执行层">3. 指令层与执行层</a></h2>
<p>算子映射到指令后，执行器的机制开始主导成本：</p>
<ul>
<li>decode cache 命中与否</li>
<li>trace 稳定性</li>
<li>MOP 融合命中率</li>
</ul>
<p>这也是为什么“同一算法”在不同执行器策略下费用表现会差异明显。</p>
<h2 id="4-计费层不是收尾步骤"><a class="header" href="#4-计费层不是收尾步骤">4. 计费层不是收尾步骤</a></h2>
<p>计费应参与设计早期，而非上线前补丁。理由：</p>
<ul>
<li>计费参数会反向影响攻击面</li>
<li>计费错误会影响生态公平性</li>
</ul>
<p>正确流程是“开发-测试-计费校准-发布”闭环，而不是线性流水。</p>
<h2 id="5-侧信道与确定性的并行治理"><a class="header" href="#5-侧信道与确定性的并行治理">5. 侧信道与确定性的并行治理</a></h2>
<p>密码学执行栈还需并行关注：</p>
<ul>
<li>功能确定性（共识）</li>
<li>恒时安全（隐私与密钥安全）</li>
</ul>
<p>两者测试体系不同，不能互相替代。</p>
<h2 id="6-闭环化实践模板"><a class="header" href="#6-闭环化实践模板">6. 闭环化实践模板</a></h2>
<p>每次密码学优化至少输出：</p>
<ol>
<li>算子画像报告</li>
<li>指令分布报告</li>
<li>执行命中报告（trace/MOP）</li>
<li>计费偏差报告</li>
<li>侧信道检查结论</li>
</ol>
<p>这样优化才算“闭环完成”。</p>
<h2 id="7-与主文映射-3"><a class="header" href="#7-与主文映射-3">7. 与主文映射</a></h2>
<ul>
<li>对应附录：<code>附录 A</code></li>
<li>关键代码：<code>src/cost_model.rs</code>, <code>src/decoder.rs</code>, <code>src/instructions/execute.rs</code></li>
<li>关联附录：<code>附录 F</code>, <code>附录 H</code>, <code>附录 I</code></li>
</ul>
<h2 id="8-一针见血结论-3"><a class="header" href="#8-一针见血结论-3">8. 一针见血结论</a></h2>
<p>密码学执行优化的成熟标志不是“跑分更高”，而是“从算法到计费的证据链闭合”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图-c-1-长文isa-到协议治理链扩展引入如何避免技术正确治理失败"><a class="header" href="#图-c-1-长文isa-到协议治理链扩展引入如何避免技术正确治理失败">图 C-1 长文：ISA 到协议治理链，扩展引入如何避免“技术正确、治理失败”</a></h1>
<h2 id="摘要-12"><a class="header" href="#摘要-12">摘要</a></h2>
<p>图 C-1 描述的是“技术决策如何转化为治理后果”。在区块链 VM 中，新扩展引入失败往往不是因为指令本身错误，而是因为缺少版本门禁、回滚路径与计费校准。</p>
<h2 id="1-原图重述-5"><a class="header" href="#1-原图重述-5">1. 原图重述</a></h2>
<pre><code class="language-text">ISA semantics
  -&gt; decoder/loader complexity
  -&gt; multi-backend consistency
  -&gt; tooling/audit cost
  -&gt; protocol upgrade governance
</code></pre>
<p>结论：扩展引入是协议治理事件，不是单次代码提交。</p>
<h2 id="2-三重门禁模型"><a class="header" href="#2-三重门禁模型">2. 三重门禁模型</a></h2>
<p>建议把扩展引入分为三重门禁：</p>
<ol>
<li>语义门禁：边界行为定义完整，测试向量完备</li>
<li>经济门禁：计费模型可校准且无明显套利窗口</li>
<li>治理门禁：灰度方案、监控指标、回滚预案齐备</li>
</ol>
<p>三门缺一，均不应上线。</p>
<h2 id="3-向量扩展v引入示例路线"><a class="header" href="#3-向量扩展v引入示例路线">3. 向量扩展（V）引入示例路线</a></h2>
<ol>
<li>先定义子集与禁用项（规范阶段）</li>
<li>先落 Rust 语义实现（可审计）</li>
<li>再做 ASM 热点加速（可控）</li>
<li>再做费用校准与灰度发布（可回滚）</li>
</ol>
<p>这个顺序本质上是“语义先于性能”。</p>
<h2 id="4-典型失败模式"><a class="header" href="#4-典型失败模式">4. 典型失败模式</a></h2>
<h3 id="失败模式-a先上快路径再补规范"><a class="header" href="#失败模式-a先上快路径再补规范">失败模式 A：先上快路径再补规范</a></h3>
<p>结果：实现先行，语义后补，差分 bug 高发。</p>
<h3 id="失败模式-b只做性能验证不做费用验证"><a class="header" href="#失败模式-b只做性能验证不做费用验证">失败模式 B：只做性能验证不做费用验证</a></h3>
<p>结果：出现计费偏差和经济性漏洞。</p>
<h3 id="失败模式-c发布无回滚预案"><a class="header" href="#失败模式-c发布无回滚预案">失败模式 C：发布无回滚预案</a></h3>
<p>结果：线上异常只能硬扛，治理成本陡增。</p>
<h2 id="5-审计资产最小包"><a class="header" href="#5-审计资产最小包">5. 审计资产最小包</a></h2>
<p>每个扩展提案至少应附：</p>
<ol>
<li>语义说明书</li>
<li>解码与执行实现说明</li>
<li>计费模型与校准报告</li>
<li>多后端差分报告</li>
<li>回滚与兼容策略</li>
</ol>
<p>这五项构成“可治理上线”的最小资产。</p>
<h2 id="6-组织协作建议"><a class="header" href="#6-组织协作建议">6. 组织协作建议</a></h2>
<ul>
<li>协议团队负责门禁定义</li>
<li>执行团队负责语义与实现</li>
<li>安全团队负责边界审计</li>
<li>运维团队负责灰度与回滚演练</li>
</ul>
<p>若职责不分，扩展引入会反复在上线期集中爆雷。</p>
<h2 id="7-与主文映射-4"><a class="header" href="#7-与主文映射-4">7. 与主文映射</a></h2>
<ul>
<li>对应附录：<code>附录 C</code></li>
<li>关键代码：<code>src/decoder.rs</code>, <code>src/machine/mod.rs</code>, <code>build.rs</code></li>
<li>关联附录：<code>附录 E</code>, <code>附录 G</code></li>
</ul>
<h2 id="8-一针见血结论-4"><a class="header" href="#8-一针见血结论-4">8. 一针见血结论</a></h2>
<p>扩展引入的成败，不取决于“指令是否可实现”，而取决于“是否可治理”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="图示长文实验通用准备"><a class="header" href="#图示长文实验通用准备">图示长文实验：通用准备</a></h1>
<h2 id="1-环境准备"><a class="header" href="#1-环境准备">1. 环境准备</a></h2>
<pre><code class="language-bash"># 在项目根目录
cd /home/jay/Code/Rust/ckb-vm

# 先编译（可选带 asm）
cargo build
cargo build --features asm
</code></pre>
<h2 id="2-推荐基础检查"><a class="header" href="#2-推荐基础检查">2. 推荐基础检查</a></h2>
<pre><code class="language-bash"># 快速烟雾测试
cargo test --test test_simple
cargo test --test test_versions
</code></pre>
<h2 id="3-一键脚本按批次自动执行并生成报告"><a class="header" href="#3-一键脚本按批次自动执行并生成报告">3. 一键脚本（按批次自动执行并生成报告）</a></h2>
<p>脚本位置：<code>docs/riscv-vm-book/tools/run_labs.sh</code></p>
<pre><code class="language-bash"># 仅跑批次一
bash docs/riscv-vm-book/tools/run_labs.sh --batch 1

# 跑全部批次（smoke 模式，跳过最重回归）
bash docs/riscv-vm-book/tools/run_labs.sh --batch all --mode smoke

# 跑全部批次并跳过 asm 指令
bash docs/riscv-vm-book/tools/run_labs.sh --batch all --skip-asm
</code></pre>
<p>输出位置（默认）：</p>
<ul>
<li><code>docs/riscv-vm-book/reports/labs/&lt;timestamp&gt;/lab-run-report.md</code></li>
<li><code>docs/riscv-vm-book/reports/labs/&lt;timestamp&gt;/lab-run-report.csv</code></li>
<li><code>docs/riscv-vm-book/reports/labs/&lt;timestamp&gt;/logs/*.log</code></li>
</ul>
<h2 id="4-常用实验命令模板"><a class="header" href="#4-常用实验命令模板">4. 常用实验命令模板</a></h2>
<pre><code class="language-bash"># 运行单个测试文件
cargo test --test test_mop -- --nocapture

# 运行单个测试函数
cargo test --test test_signal_pause test_int_pause -- --nocapture

# 运行示例 runner（解释器）
cargo run --example ckb_vm_runner -- --mode interpreter64 tests/programs/simple64

# 运行示例 runner（asm，需要 --features asm）
cargo run --features asm --example ckb_vm_runner -- --mode asm64 tests/programs/simple64
</code></pre>
<h2 id="5-结果记录建议"><a class="header" href="#5-结果记录建议">5. 结果记录建议</a></h2>
<p>每次实验最少记录：</p>
<ul>
<li>命令行</li>
<li>输入程序</li>
<li>后端模式（interpreter/asm）</li>
<li>退出码</li>
<li>cycles（若输出）</li>
<li>关键差异（若有）</li>
</ul>
<h2 id="6-注意事项"><a class="header" href="#6-注意事项">6. 注意事项</a></h2>
<ul>
<li>若系统使用 <code>rustup</code> 并提示权限问题，先检查本机 rustup 目录写权限。</li>
<li>Windows/macOS/Linux 的可用后端可能不同，以 <code>build.rs</code> 条件为准。</li>
<li>对拍实验必须保持同一程序、同一参数、同一 VM 版本。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="批次一实验手册图-1-1-到-4-1"><a class="header" href="#批次一实验手册图-1-1-到-4-1">批次一实验手册（图 1-1 到 4-1）</a></h1>
<blockquote>
<p>对应长文：批次一四篇图示拆解长文</p>
</blockquote>
<h2 id="lab-1图-1-1确定性与计费边界"><a class="header" href="#lab-1图-1-1确定性与计费边界">Lab 1（图 1-1）：确定性与计费边界</a></h2>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<p>验证“同输入同输出”和“max_cycles 边界触发”的基本行为。</p>
<h3 id="命令"><a class="header" href="#命令">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_simple test_simple_cycles -- --nocapture
cargo test --test test_simple test_simple_max_cycles_reached -- --nocapture
</code></pre>
<h3 id="预期"><a class="header" href="#预期">预期</a></h3>
<ul>
<li>前者通过并能体现 cycles 统计逻辑。</li>
<li>后者触发 <code>CyclesExceeded</code> 相关行为（以测试断言为准）。</li>
</ul>
<h2 id="lab-2图-2-1生命周期与-pauseresume"><a class="header" href="#lab-2图-2-1生命周期与-pauseresume">Lab 2（图 2-1）：生命周期与 pause/resume</a></h2>
<h3 id="目标-1"><a class="header" href="#目标-1">目标</a></h3>
<p>验证运行循环可被中断并稳定恢复。</p>
<h3 id="命令-1"><a class="header" href="#命令-1">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_signal_pause -- --nocapture
</code></pre>
<h3 id="预期-1"><a class="header" href="#预期-1">预期</a></h3>
<ul>
<li><code>test_asm_pause</code> / <code>test_int_pause</code> 通过。</li>
<li>pause 语义在解释器和 asm 路径都可观测。</li>
</ul>
<h2 id="lab-3图-3-1装载与权限边界"><a class="header" href="#lab-3图-3-1装载与权限边界">Lab 3（图 3-1）：装载与权限边界</a></h2>
<h3 id="目标-2"><a class="header" href="#目标-2">目标</a></h3>
<p>验证版本与边界行为（argv/sp/边界读写）不会随意漂移。</p>
<h3 id="命令-2"><a class="header" href="#命令-2">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_versions -- --nocapture
cargo test --test test_error -- --nocapture
</code></pre>
<h3 id="预期-2"><a class="header" href="#预期-2">预期</a></h3>
<ul>
<li>版本相关测试全部通过。</li>
<li>错误类型保持结构化可断言。</li>
</ul>
<h2 id="lab-4图-4-1解码优化与-mop-路径"><a class="header" href="#lab-4图-4-1解码优化与-mop-路径">Lab 4（图 4-1）：解码优化与 MOP 路径</a></h2>
<h3 id="目标-3"><a class="header" href="#目标-3">目标</a></h3>
<p>验证 MOP 相关测试在真实程序上可通过。</p>
<h3 id="命令-3"><a class="header" href="#命令-3">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_mop -- --nocapture
</code></pre>
<h3 id="预期-3"><a class="header" href="#预期-3">预期</a></h3>
<ul>
<li>wide mul/div、far jump、adc/add3 等测试通过。</li>
<li>可观察到融合路径在测试中被覆盖。</li>
</ul>
<h2 id="扩展任务"><a class="header" href="#扩展任务">扩展任务</a></h2>
<ul>
<li>用 <code>ckb_vm_runner</code> 对同一程序分别跑 interpreter64 和 asm64，比较退出码与 cycles。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="批次二实验手册图-5-1-到-8-1"><a class="header" href="#批次二实验手册图-5-1-到-8-1">批次二实验手册（图 5-1 到 8-1）</a></h1>
<blockquote>
<p>对应长文：批次二四篇图示拆解长文</p>
</blockquote>
<h2 id="lab-5图-5-1ecall-与宿主边界"><a class="header" href="#lab-5图-5-1ecall-与宿主边界">Lab 5（图 5-1）：ecall 与宿主边界</a></h2>
<h3 id="目标-4"><a class="header" href="#目标-4">目标</a></h3>
<p>验证 syscall 处理路径和未处理路径错误行为。</p>
<h3 id="命令-4"><a class="header" href="#命令-4">命令</a></h3>
<pre><code class="language-bash">cargo run --example ckb_vm_runner -- --mode interpreter64 tests/programs/simple64
cargo test --test test_error -- --nocapture
</code></pre>
<h3 id="预期-4"><a class="header" href="#预期-4">预期</a></h3>
<ul>
<li>程序能通过 ecall 正常退出。</li>
<li>错误路径仍由结构化错误承接。</li>
</ul>
<h2 id="lab-6图-6-1快照恢复一致性"><a class="header" href="#lab-6图-6-1快照恢复一致性">Lab 6（图 6-1）：快照恢复一致性</a></h2>
<h3 id="目标-1-1"><a class="header" href="#目标-1-1">目标</a></h3>
<p>验证 snapshot/snapshot2 的恢复链路在不同后端可用。</p>
<h3 id="命令-1-1"><a class="header" href="#命令-1-1">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_resume -- --nocapture
cargo test --test test_resume2 -- --nocapture
</code></pre>
<h3 id="预期-1-1"><a class="header" href="#预期-1-1">预期</a></h3>
<ul>
<li>interpreter -&gt; asm / asm -&gt; interpreter 场景通过。</li>
<li>快照后继续执行结果保持一致。</li>
</ul>
<h2 id="lab-7图-7-1register-语义边界"><a class="header" href="#lab-7图-7-1register-语义边界">Lab 7（图 7-1）：Register 语义边界</a></h2>
<h3 id="目标-2-1"><a class="header" href="#目标-2-1">目标</a></h3>
<p>通过指令集合测试覆盖整数、位操作与边界行为。</p>
<h3 id="命令-2-1"><a class="header" href="#命令-2-1">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_b_extension -- --nocapture
cargo test --test test_a_extension -- --nocapture
cargo test --test test_simple -- --nocapture
</code></pre>
<h3 id="预期-2-1"><a class="header" href="#预期-2-1">预期</a></h3>
<ul>
<li>扩展指令行为稳定。</li>
<li>边界测试（如 overflow/invalid bits）保持通过。</li>
</ul>
<h2 id="lab-8图-8-1rustasm-混合路径一致性"><a class="header" href="#lab-8图-8-1rustasm-混合路径一致性">Lab 8（图 8-1）：Rust/ASM 混合路径一致性</a></h2>
<h3 id="目标-3-1"><a class="header" href="#目标-3-1">目标</a></h3>
<p>验证 asm 后端与解释器后端在核心测试集上行为一致。</p>
<h3 id="命令-3-1"><a class="header" href="#命令-3-1">命令</a></h3>
<pre><code class="language-bash">cargo test --features asm --test test_asm -- --nocapture
cargo test --features asm --test test_simple -- --nocapture
cargo test --features asm --test test_versions -- --nocapture
</code></pre>
<h3 id="预期-3-1"><a class="header" href="#预期-3-1">预期</a></h3>
<ul>
<li>asm 相关测试通过。</li>
<li>不同后端在同测试语义下无显著偏差。</li>
</ul>
<h2 id="扩展任务-1"><a class="header" href="#扩展任务-1">扩展任务</a></h2>
<ul>
<li>选取 <code>tests/programs/mop_wide_multiply</code>，分别以 <code>interpreter64</code> 和 <code>asm64</code> 跑并记录输出。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="批次三实验手册图-9-110-111-1a-1c-1"><a class="header" href="#批次三实验手册图-9-110-111-1a-1c-1">批次三实验手册（图 9-1、10-1、11-1、A-1、C-1）</a></h1>
<blockquote>
<p>对应长文：批次三五篇图示拆解长文</p>
</blockquote>
<h2 id="lab-9图-9-1isa-与版本治理"><a class="header" href="#lab-9图-9-1isa-与版本治理">Lab 9（图 9-1）：ISA 与版本治理</a></h2>
<h3 id="目标-5"><a class="header" href="#目标-5">目标</a></h3>
<p>验证版本相关行为与历史兼容测试。</p>
<h3 id="命令-5"><a class="header" href="#命令-5">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_versions -- --nocapture
cargo test --test test_misc -- --nocapture
</code></pre>
<h3 id="预期-5"><a class="header" href="#预期-5">预期</a></h3>
<ul>
<li>不同版本语义测试稳定通过。</li>
<li>ISA/版本边界问题能被测试覆盖。</li>
</ul>
<h2 id="lab-10图-10-1密码学扩展路径"><a class="header" href="#lab-10图-10-1密码学扩展路径">Lab 10（图 10-1）：密码学扩展路径</a></h2>
<h3 id="目标-1-2"><a class="header" href="#目标-1-2">目标</a></h3>
<p>验证 B/MOP 等扩展在密码学相关程序上可用。</p>
<h3 id="命令-1-2"><a class="header" href="#命令-1-2">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_mop -- --nocapture
cargo test --test test_b_extension -- --nocapture
</code></pre>
<h3 id="预期-1-2"><a class="header" href="#预期-1-2">预期</a></h3>
<ul>
<li>MOP 与 B 扩展主要测试通过。</li>
<li>可用于后续计费校准对照。</li>
</ul>
<h2 id="lab-11图-11-1收益-成本矩阵的回归视角"><a class="header" href="#lab-11图-11-1收益-成本矩阵的回归视角">Lab 11（图 11-1）：收益-成本矩阵的回归视角</a></h2>
<h3 id="目标-2-2"><a class="header" href="#目标-2-2">目标</a></h3>
<p>用回归测试近似验证“优化不破坏语义”。</p>
<h3 id="命令-2-2"><a class="header" href="#命令-2-2">命令</a></h3>
<pre><code class="language-bash">cargo test --all -- --nocapture
</code></pre>
<h3 id="预期-2-2"><a class="header" href="#预期-2-2">预期</a></h3>
<ul>
<li>全测试集通过。</li>
<li>若有失败，优先定位“后端差分或版本边界”问题。</li>
</ul>
<h2 id="lab-a1图-a-1密码学执行栈闭环采样"><a class="header" href="#lab-a1图-a-1密码学执行栈闭环采样">Lab A1（图 A-1）：密码学执行栈闭环采样</a></h2>
<h3 id="目标-3-2"><a class="header" href="#目标-3-2">目标</a></h3>
<p>形成“测试 -&gt; 指令热点 -&gt; 计费观察”的闭环记录。</p>
<h3 id="命令-3-2"><a class="header" href="#命令-3-2">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_mop -- --nocapture
cargo test --test test_simple test_simple_cycles -- --nocapture
</code></pre>
<h3 id="记录模板"><a class="header" href="#记录模板">记录模板</a></h3>
<ul>
<li>测试用例：</li>
<li>后端：</li>
<li>观察到的热点行为：</li>
<li>cycles 变化：</li>
<li>结论：</li>
</ul>
<h2 id="lab-c1图-c-1扩展引入治理演练"><a class="header" href="#lab-c1图-c-1扩展引入治理演练">Lab C1（图 C-1）：扩展引入治理演练</a></h2>
<h3 id="目标-4-1"><a class="header" href="#目标-4-1">目标</a></h3>
<p>模拟“功能变更后发布门禁”流程：</p>
<ol>
<li>运行核心测试</li>
<li>运行后端相关测试</li>
<li>填写审计模板</li>
</ol>
<h3 id="命令-4-1"><a class="header" href="#命令-4-1">命令</a></h3>
<pre><code class="language-bash">cargo test --test test_versions -- --nocapture
cargo test --features asm --test test_asm -- --nocapture
</code></pre>
<h3 id="配套文档"><a class="header" href="#配套文档">配套文档</a></h3>
<ul>
<li>审计模板：<code>附录 F</code></li>
<li>改稿清单：<code>附录 G</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="课程地图rust--risc-v-区块链-vm-工程训练"><a class="header" href="#课程地图rust--risc-v-区块链-vm-工程训练">课程地图：Rust + RISC-V 区块链 VM 工程训练</a></h1>
<h2 id="课程目标"><a class="header" href="#课程目标">课程目标</a></h2>
<ol>
<li>建立“共识约束优先”的架构直觉。</li>
<li>掌握 <code>ckb-vm</code> 执行主线与关键边界。</li>
<li>能独立完成一次优化改动的风险评审。</li>
</ol>
<h2 id="课程结构建议-3-天"><a class="header" href="#课程结构建议-3-天">课程结构（建议 3 天）</a></h2>
<h3 id="day-1执行与边界"><a class="header" href="#day-1执行与边界">Day 1：执行与边界</a></h3>
<ul>
<li>主文第 1-4 章</li>
<li>图示长文批次一</li>
<li>实验手册批次一</li>
</ul>
<h3 id="day-2系统与语义"><a class="header" href="#day-2系统与语义">Day 2：系统与语义</a></h3>
<ul>
<li>主文第 5-8 章</li>
<li>图示长文批次二</li>
<li>实验手册批次二</li>
</ul>
<h3 id="day-3治理与专题"><a class="header" href="#day-3治理与专题">Day 3：治理与专题</a></h3>
<ul>
<li>主文第 9-11 章 + 附录 A/C</li>
<li>图示长文批次三</li>
<li>实验手册批次三</li>
<li>练习题与讲评</li>
</ul>
<h2 id="产出要求"><a class="header" href="#产出要求">产出要求</a></h2>
<ul>
<li>每位学员提交：
<ul>
<li>一份架构评审报告（1-2 页）</li>
<li>一份实验记录表（最少 3 个实验）</li>
<li>一份 PR 审计模板演练结果（附录 F）</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="教学讲义模块化"><a class="header" href="#教学讲义模块化">教学讲义（模块化）</a></h1>
<h2 id="模块一共识-vm-的第一性原理"><a class="header" href="#模块一共识-vm-的第一性原理">模块一：共识 VM 的第一性原理</a></h2>
<h3 id="核心问题"><a class="header" href="#核心问题">核心问题</a></h3>
<ul>
<li>为什么区块链 VM 不能只谈吞吐？</li>
<li>为什么错误语义与计费语义必须结构化？</li>
</ul>
<h3 id="课堂要点"><a class="header" href="#课堂要点">课堂要点</a></h3>
<ul>
<li>图 1-1 约束层级</li>
<li>图 2-1 生命周期状态机</li>
<li>图 3-1 装载与权限边界</li>
</ul>
<h3 id="课堂讨论题"><a class="header" href="#课堂讨论题">课堂讨论题</a></h3>
<ul>
<li>如果去掉 <code>max_cycles</code>，系统会暴露什么攻击面？</li>
<li>为什么 W^X 是共识层问题而非普通安全硬化？</li>
</ul>
<h2 id="模块二执行优化与语义锚点"><a class="header" href="#模块二执行优化与语义锚点">模块二：执行优化与语义锚点</a></h2>
<h3 id="核心问题-1"><a class="header" href="#核心问题-1">核心问题</a></h3>
<ul>
<li>Trace/MOP/ASM 优化如何不破坏语义？</li>
<li>为什么要保留 Rust 语义主线？</li>
</ul>
<h3 id="课堂要点-1"><a class="header" href="#课堂要点-1">课堂要点</a></h3>
<ul>
<li>图 4-1 解码快路径</li>
<li>图 7-1 trait 语义下沉</li>
<li>图 8-1 Rust+ASM 控制平面</li>
</ul>
<h3 id="课堂讨论题-1"><a class="header" href="#课堂讨论题-1">课堂讨论题</a></h3>
<ul>
<li>什么时候 <code>RET_SLOWPATH</code> 是必需而不是“性能缺陷”？</li>
<li>trait 语义契约需要哪些合约测试？</li>
</ul>
<h2 id="模块三治理密码学与发布门禁"><a class="header" href="#模块三治理密码学与发布门禁">模块三：治理、密码学与发布门禁</a></h2>
<h3 id="核心问题-2"><a class="header" href="#核心问题-2">核心问题</a></h3>
<ul>
<li>ISA 选择如何影响协议寿命？</li>
<li>密码学优化如何避免“跑分快、上线险”？</li>
</ul>
<h3 id="课堂要点-2"><a class="header" href="#课堂要点-2">课堂要点</a></h3>
<ul>
<li>图 9-1 ISA 影响链</li>
<li>图 10-1 扩展分工</li>
<li>图 11-1 收益-成本矩阵</li>
<li>图 A-1/C-1 闭环与治理链</li>
</ul>
<h3 id="课堂讨论题-2"><a class="header" href="#课堂讨论题-2">课堂讨论题</a></h3>
<ul>
<li>新扩展引入最小门禁是什么？</li>
<li>计费校准为何是安全工作而不是“调参”？</li>
</ul>
<h2 id="讲师提示"><a class="header" href="#讲师提示">讲师提示</a></h2>
<ul>
<li>把“代码锚点”作为讲授主线，避免抽象空转。</li>
<li>每个模块结束前，要求学员写一条“一针见血结论”。</li>
<li>不讲“最佳实践神话”，只讲“可复现证据”。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="练习题教学版"><a class="header" href="#练习题教学版">练习题（教学版）</a></h1>
<h2 id="a-组理解题基础"><a class="header" href="#a-组理解题基础">A 组：理解题（基础）</a></h2>
<ol>
<li>用你自己的话解释图 1-1 四层约束的先后关系。</li>
<li>为什么 <code>Machine::ecall</code> 默认只处理 <code>93</code> 是合理设计？</li>
<li><code>Snapshot2</code> 相比 <code>Snapshot</code> 的核心收益是什么？</li>
<li><code>Register</code> trait 为什么是共识安全问题？</li>
</ol>
<h2 id="b-组分析题进阶"><a class="header" href="#b-组分析题进阶">B 组：分析题（进阶）</a></h2>
<ol>
<li>设计一个“错误的 MOP 融合规则”反例，并说明会导致何种语义漂移。</li>
<li>假设某扩展上线后 cycles 降低 20%，但长尾交易更慢。你如何判断是否应发布？</li>
<li>解释为什么“确定性通过”不等于“恒时安全通过”。</li>
<li>给出一个 Rust/ASM 差分测试最小矩阵。</li>
</ol>
<h2 id="c-组实操题工程"><a class="header" href="#c-组实操题工程">C 组：实操题（工程）</a></h2>
<ol>
<li>运行并记录以下实验：</li>
</ol>
<pre><code class="language-bash">cargo test --test test_mop -- --nocapture
cargo test --test test_resume2 -- --nocapture
cargo test --features asm --test test_asm -- --nocapture
</code></pre>
<p>输出内容要求：</p>
<ul>
<li>每条命令的目的</li>
<li>关键观测</li>
<li>风险判断</li>
</ul>
<ol start="2">
<li>
<p>使用附录 F 模板，模拟审计一次“优化 PR”（可虚拟场景）。</p>
</li>
<li>
<p>使用附录 G 清单，检查你提交的报告是否达到“可评审”标准。</p>
</li>
</ol>
<h2 id="d-组挑战题治理"><a class="header" href="#d-组挑战题治理">D 组：挑战题（治理）</a></h2>
<ol>
<li>写一份“V 扩展引入最小门禁方案”（1 页以内）。</li>
<li>定义三个可以长期监控的执行层治理指标，并说明阈值建议。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="练习题参考答案与评分建议"><a class="header" href="#练习题参考答案与评分建议">练习题参考答案与评分建议</a></h1>
<blockquote>
<p>评分建议：100 分制，A 组 20 分，B 组 30 分，C 组 35 分，D 组 15 分。</p>
</blockquote>
<h2 id="a-组参考"><a class="header" href="#a-组参考">A 组参考</a></h2>
<ul>
<li>关键看是否理解“协议约束优先于性能优化”。</li>
<li>能解释 <code>ecall=93</code> 的内核闭环意义可得满分。</li>
<li>能区分 snapshot v1/v2 的“复制 vs 引用”差异可得满分。</li>
</ul>
<h2 id="b-组参考"><a class="header" href="#b-组参考">B 组参考</a></h2>
<ul>
<li>MOP 反例应至少说明：寄存器状态不等价或 PC 前进不等价。</li>
<li>发布判断应包含语义、计费、治理三维，而非只看性能。</li>
<li>“确定性 vs 恒时”需明确是两套验证目标。</li>
<li>差分矩阵至少包含后端、输入集、比较指标三要素。</li>
</ul>
<h2 id="c-组评分要点"><a class="header" href="#c-组评分要点">C 组评分要点</a></h2>
<ul>
<li>命令执行记录是否完整（命令、结果、结论）。</li>
<li>能否把测试结果映射到风险判断。</li>
<li>F/G 模板填写是否具体，不应只有口号。</li>
</ul>
<h2 id="d-组评分要点"><a class="header" href="#d-组评分要点">D 组评分要点</a></h2>
<ul>
<li>V 扩展方案应有门禁、灰度、回滚三部分。</li>
<li>指标应可观测、可阈值化、可持续跟踪。</li>
</ul>
<h2 id="扣分项"><a class="header" href="#扣分项">扣分项</a></h2>
<ul>
<li>只复述主文结论、不提供证据。</li>
<li>只谈性能，不谈兼容与治理。</li>
<li>模板填写空泛，无法执行。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-a-密码学专题工作负载指令映射与审计框架"><a class="header" href="#附录-a-密码学专题工作负载指令映射与审计框架">附录 A 密码学专题：工作负载、指令映射与审计框架</a></h1>
<h2 id="a1-目标与范围"><a class="header" href="#a1-目标与范围">A.1 目标与范围</a></h2>
<p>本附录回答三个实战问题：</p>
<ol>
<li>链上密码学负载在 VM 中到底花在哪些指令类型上？</li>
<li><code>ckb-vm</code> 的 B/M/A/MOP 设计分别解决了什么真实瓶颈？</li>
<li>如何把“优化”转化为“可验证、可计费、可审计”的发布资产？</li>
</ol>
<p>本文聚焦三类工作负载：</p>
<ul>
<li>secp256k1（大整数和椭圆曲线主导）</li>
<li>哈希族（SHA-256/BLAKE2b）</li>
<li>Merkle 验证与序列化路径</li>
</ul>
<h2 id="a2-图-a-1密码学执行分层"><a class="header" href="#a2-图-a-1密码学执行分层">A.2 图 A-1：密码学执行分层</a></h2>
<pre><code class="language-text">算法层:   ECDSA/Schnorr, SHA-2, BLAKE2b, Merkle proof
算子层:   mul/div/addcarry, bit-mix, permutation, memory moves
指令层:   IMC + B + M + A + MOP
执行层:   decode cache + trace + asm fastpath
计费层:   cycles model + max_cycles guard
</code></pre>
<p>核心判断：密码学优化不是单指令竞速，而是跨层协同。</p>
<h2 id="a3-secp256k1-负载画像"><a class="header" href="#a3-secp256k1-负载画像">A.3 secp256k1 负载画像</a></h2>
<h3 id="a31-高占比算子"><a class="header" href="#a31-高占比算子">A.3.1 高占比算子</a></h3>
<ul>
<li>256 位乘法扩展（结果 512 位）</li>
<li>模约简（乘加、减法、条件选择）</li>
<li>点加/点倍的有限域链式运算</li>
</ul>
<h3 id="a32-ckb-vm-指令映射"><a class="header" href="#a32-ckb-vm-指令映射">A.3.2 <code>ckb-vm</code> 指令映射</a></h3>
<ul>
<li><code>M</code> 扩展：基础乘除语义</li>
<li><code>MOP</code>：<code>WIDE_MUL/WIDE_DIV/ADD3*</code> 压缩高频算术模板</li>
<li><code>Trace</code>：降低循环体重复解码和分发开销</li>
</ul>
<p>对应代码锚点：</p>
<ul>
<li><code>src/instructions/execute.rs</code></li>
<li><code>src/decoder.rs</code></li>
<li><code>src/machine/trace.rs</code></li>
</ul>
<h3 id="a33-关键结论"><a class="header" href="#a33-关键结论">A.3.3 关键结论</a></h3>
<p>大整数路径常见瓶颈是“调度开销 + 指令链长度”，而非单算子理论峰值。</p>
<h2 id="a4-哈希负载画像sha-256blake2b"><a class="header" href="#a4-哈希负载画像sha-256blake2b">A.4 哈希负载画像（SHA-256/BLAKE2b）</a></h2>
<h3 id="a41-高占比算子"><a class="header" href="#a41-高占比算子">A.4.1 高占比算子</a></h3>
<ul>
<li>rotate/shift/xor</li>
<li>字节重排与消息扩展</li>
<li>固定轮函数的高频循环</li>
</ul>
<h3 id="a42-指令映射"><a class="header" href="#a42-指令映射">A.4.2 指令映射</a></h3>
<ul>
<li><code>B</code> 扩展：<code>REV8/ORCB/CLMUL*</code> 与各类位操作</li>
<li>IMC：基础加载存储和算术逻辑</li>
<li><code>Trace</code>：稳定循环体高命中，收益可观</li>
</ul>
<h3 id="a43-关键结论"><a class="header" href="#a43-关键结论">A.4.3 关键结论</a></h3>
<p>哈希路径收益来自“位操作收敛 + 循环体命中”，不是某一条魔法指令。</p>
<h2 id="a5-merkle-验证与序列化路径"><a class="header" href="#a5-merkle-验证与序列化路径">A.5 Merkle 验证与序列化路径</a></h2>
<p>Merkle 负载常由“频繁小块哈希 + 边界拼接”组成。主要风险在于：</p>
<ul>
<li>不必要的数据拷贝</li>
<li>syscall 边界过细导致陷入频率过高</li>
<li>计费模型未覆盖小块高频模式</li>
</ul>
<p>建议优先优化数据布局与调用边界，再优化单条算术路径。</p>
<h2 id="a6-扩展价值矩阵"><a class="header" href="#a6-扩展价值矩阵">A.6 扩展价值矩阵</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>扩展/机制</th><th>主要收益点</th><th>典型负载</th><th>风险点</th></tr>
</thead>
<tbody>
<tr><td>B</td><td>位操作压缩</td><td>哈希、比特域计算</td><td>指令覆盖不完整导致回退频繁</td></tr>
<tr><td>M</td><td>乘除语义原生化</td><td>大整数、模运算</td><td>cycles 估值偏差</td></tr>
<tr><td>A</td><td>原子语义支持</td><td>并发协议/锁语义模拟</td><td>非核心密码学热点</td></tr>
<tr><td>MOP</td><td>高频模式融合</td><td>乘加进位链</td><td>等价性验证复杂</td></tr>
<tr><td>Trace</td><td>降低解释器噪声</td><td>稳定循环体</td><td>cache 命中退化</td></tr>
</tbody>
</table>
</div>
<h2 id="a7-计费校准框架出版版"><a class="header" href="#a7-计费校准框架出版版">A.7 计费校准框架（出版版）</a></h2>
<h3 id="a71-校准流程"><a class="header" href="#a71-校准流程">A.7.1 校准流程</a></h3>
<ol>
<li>采集真实合约 trace（而非 microbenchmark）。</li>
<li>统计 opcode 和融合 opcode 占比。</li>
<li>比较“cycles 估值”与“实际执行成本”偏差。</li>
<li>回归更新 <code>estimate_cycles</code>，并做跨版本对拍。</li>
</ol>
<h3 id="a72-需长期追踪的指标"><a class="header" href="#a72-需长期追踪的指标">A.7.2 需长期追踪的指标</a></h3>
<ul>
<li><code>cycles_per_tx</code> 分布</li>
<li>opcode 热点排名变化</li>
<li>DoS 可疑交易的成本密度</li>
<li>版本升级前后费用漂移</li>
</ul>
<h2 id="a8-恒时安全与确定性的边界"><a class="header" href="#a8-恒时安全与确定性的边界">A.8 恒时安全与确定性的边界</a></h2>
<p>需要明确：</p>
<ul>
<li>VM 确定性保证的是“结果一致”。</li>
<li>恒时安全关注的是“执行轨迹不泄露秘密”。</li>
</ul>
<p>两者相关但不等价。密码学库仍需：</p>
<ul>
<li>避免 secret-dependent 分支</li>
<li>避免 secret-dependent 访存</li>
<li>用审计与测试验证恒时性质</li>
</ul>
<h2 id="a9-反例分析优化-kpi-与安全-kpi-断裂"><a class="header" href="#a9-反例分析优化-kpi-与安全-kpi-断裂">A.9 反例分析：优化 KPI 与安全 KPI 断裂</a></h2>
<p>反例场景：团队仅追求“TPS 提升 20%”，不做等价验证与计费校准。</p>
<p>后果通常是：</p>
<ul>
<li>热点负载性能提升不明显，冷路径语义反而漂移。</li>
<li>费用模型失真，出现低成本重计算窗口。</li>
</ul>
<p>教训：密码学优化必须同时满足“功能等价 + 计费一致 + 安全边界不退化”。</p>
<h2 id="a10-审计清单出版版"><a class="header" href="#a10-审计清单出版版">A.10 审计清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 是否覆盖 secp/hash/Merkle 三类代表性 workload。</li>
<li><input disabled="" type="checkbox"> MOP 融合是否有等价性测试与反例测试。</li>
<li><input disabled="" type="checkbox"> Rust/ASM 双后端是否做密码学路径差分回归。</li>
<li><input disabled="" type="checkbox"> cycles 模型是否按版本持续校准。</li>
<li><input disabled="" type="checkbox"> 是否单独评估恒时风险，不与确定性测试混用。</li>
</ul>
<h2 id="a11-采样模板可直接落地"><a class="header" href="#a11-采样模板可直接落地">A.11 采样模板（可直接落地）</a></h2>
<pre><code class="language-text">Workload: secp256k1_verify_batch
Input size: N signatures
Backend: rust-trace / asm
VM version: VERSION2
ISA flags: IMC|B|A|MOP

Metrics:
- total cycles
- top 20 opcodes
- MOP hit ratio
- trace miss ratio
- syscall count
</code></pre>
<h2 id="a12-发布门禁建议"><a class="header" href="#a12-发布门禁建议">A.12 发布门禁建议</a></h2>
<ol>
<li>性能门禁：关键 workload 不低于基线。</li>
<li>语义门禁：跨后端、跨平台差分一致。</li>
<li>计费门禁：费用曲线变化在阈值内。</li>
<li>安全门禁：新增路径完成侧信道风险复核。</li>
</ol>
<h2 id="a13-一针见血结论"><a class="header" href="#a13-一针见血结论">A.13 一针见血结论</a></h2>
<p>密码学专题的本质不是“让几条指令更快”，而是把高频密码学模式收敛成可预测成本、可证明语义、可持续治理的执行体系。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-f-密码学实现审计模板pr-直用版"><a class="header" href="#附录-f-密码学实现审计模板pr-直用版">附录 F 密码学实现审计模板（PR 直用版）</a></h1>
<blockquote>
<p>用途：用于审查任何引入或修改密码学实现（签名、哈希、Merkle、大整数）的 PR。<br>结论必须可复现、可对拍、可回滚。</p>
</blockquote>
<h2 id="f1-pr-基本信息"><a class="header" href="#f1-pr-基本信息">F.1 PR 基本信息</a></h2>
<ul>
<li>PR 标题：</li>
<li>PR 链接：</li>
<li>负责人：</li>
<li>审计人：</li>
<li>目标模块：</li>
<li>关联 issue/RFC：</li>
<li>影响范围（合约/VM/宿主）：</li>
</ul>
<h2 id="f2-变更分类必选"><a class="header" href="#f2-变更分类必选">F.2 变更分类（必选）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 新增算法实现</li>
<li><input disabled="" type="checkbox"> 现有算法重构</li>
<li><input disabled="" type="checkbox"> 性能优化（无语义变更）</li>
<li><input disabled="" type="checkbox"> 指令映射调整（如 MOP/B 扩展路径）</li>
<li><input disabled="" type="checkbox"> 计费模型调整（cycles/gas）</li>
<li><input disabled="" type="checkbox"> 汇编快路径变更</li>
</ul>
<h2 id="f3-威胁模型与安全目标"><a class="header" href="#f3-威胁模型与安全目标">F.3 威胁模型与安全目标</a></h2>
<h3 id="f31-资产"><a class="header" href="#f31-资产">F.3.1 资产</a></h3>
<ul>
<li>需要保护的秘密数据：</li>
<li>需要保证的一致性状态：</li>
</ul>
<h3 id="f32-攻击面"><a class="header" href="#f32-攻击面">F.3.2 攻击面</a></h3>
<ul>
<li><input disabled="" type="checkbox"> 输入构造攻击</li>
<li><input disabled="" type="checkbox"> 计费绕过/DoS</li>
<li><input disabled="" type="checkbox"> 侧信道（时序/访存）</li>
<li><input disabled="" type="checkbox"> 多后端语义漂移</li>
<li><input disabled="" type="checkbox"> 宿主边界滥用</li>
</ul>
<h3 id="f33-安全目标"><a class="header" href="#f33-安全目标">F.3.3 安全目标</a></h3>
<ul>
<li><input disabled="" type="checkbox"> 功能正确性</li>
<li><input disabled="" type="checkbox"> 共识确定性</li>
<li><input disabled="" type="checkbox"> 计费公平性</li>
<li><input disabled="" type="checkbox"> 恒时约束（如适用）</li>
</ul>
<h2 id="f4-规范一致性检查"><a class="header" href="#f4-规范一致性检查">F.4 规范一致性检查</a></h2>
<ul>
<li>参考规范文档：</li>
<li>关键边界行为（除零/溢出/无效输入）说明：</li>
<li>与既有实现兼容性说明：</li>
</ul>
<p>检查项：</p>
<ul>
<li><input disabled="" type="checkbox"> 边界条件均有测试向量</li>
<li><input disabled="" type="checkbox"> 与规范语义逐条映射</li>
<li><input disabled="" type="checkbox"> 无未定义行为依赖</li>
</ul>
<h2 id="f5-共识一致性检查"><a class="header" href="#f5-共识一致性检查">F.5 共识一致性检查</a></h2>
<h3 id="f51-跨后端对拍"><a class="header" href="#f51-跨后端对拍">F.5.1 跨后端对拍</a></h3>
<ul>
<li>后端矩阵：<code>rust-trace</code> / <code>asm</code></li>
<li>对拍范围：</li>
<li>结果：</li>
</ul>
<h3 id="f52-跨平台对拍如可用"><a class="header" href="#f52-跨平台对拍如可用">F.5.2 跨平台对拍（如可用）</a></h3>
<ul>
<li>平台矩阵：</li>
<li>结果：</li>
</ul>
<p>检查项：</p>
<ul>
<li><input disabled="" type="checkbox"> 相同输入 -&gt; 相同输出</li>
<li><input disabled="" type="checkbox"> 相同输入 -&gt; 相同错误码</li>
<li><input disabled="" type="checkbox"> 相同输入 -&gt; 相同关键状态（寄存器/内存）</li>
</ul>
<h2 id="f6-恒时与侧信道检查密码学必看"><a class="header" href="#f6-恒时与侧信道检查密码学必看">F.6 恒时与侧信道检查（密码学必看）</a></h2>
<ul>
<li>secret-dependent 分支评估：</li>
<li>secret-dependent 访存评估：</li>
<li>汇编路径是否保持恒时约束：</li>
</ul>
<p>检查项：</p>
<ul>
<li><input disabled="" type="checkbox"> 无基于秘密的分支路径差异</li>
<li><input disabled="" type="checkbox"> 无基于秘密的内存访问模式差异</li>
<li><input disabled="" type="checkbox"> 性能优化未破坏恒时约束</li>
</ul>
<h2 id="f7-内存与权限模型检查"><a class="header" href="#f7-内存与权限模型检查">F.7 内存与权限模型检查</a></h2>
<ul>
<li>是否触及 <code>WXorXMemory</code> 边界：</li>
<li>是否新增页权限转换：</li>
<li>是否新增 unsafe 或指针操作：</li>
</ul>
<p>检查项：</p>
<ul>
<li><input disabled="" type="checkbox"> 无写可执行页行为</li>
<li><input disabled="" type="checkbox"> 越界路径有明确错误返回</li>
<li><input disabled="" type="checkbox"> unsafe 代码有最小化与注释说明</li>
</ul>
<h2 id="f8-计费与经济安全检查"><a class="header" href="#f8-计费与经济安全检查">F.8 计费与经济安全检查</a></h2>
<ul>
<li>cycles 变化摘要：</li>
<li>代表性 workload：</li>
<li>校准方法：</li>
</ul>
<p>检查项：</p>
<ul>
<li><input disabled="" type="checkbox"> 提供前后对比基线</li>
<li><input disabled="" type="checkbox"> 热点负载费用变化可解释</li>
<li><input disabled="" type="checkbox"> 无明显低成本高计算窗口</li>
</ul>
<h2 id="f9-测试与验证证据"><a class="header" href="#f9-测试与验证证据">F.9 测试与验证证据</a></h2>
<h3 id="f91-必要测试"><a class="header" href="#f91-必要测试">F.9.1 必要测试</a></h3>
<ul>
<li><input disabled="" type="checkbox"> 单元测试</li>
<li><input disabled="" type="checkbox"> 属性测试（proptest/fuzz）</li>
<li><input disabled="" type="checkbox"> 回归测试</li>
<li><input disabled="" type="checkbox"> 差分测试</li>
<li><input disabled="" type="checkbox"> 代表性 workload 基准</li>
</ul>
<h3 id="f92-产物链接"><a class="header" href="#f92-产物链接">F.9.2 产物链接</a></h3>
<ul>
<li>测试报告：</li>
<li>对拍报告：</li>
<li>基准报告：</li>
</ul>
<h2 id="f10-代码审查重点逐项结论"><a class="header" href="#f10-代码审查重点逐项结论">F.10 代码审查重点（逐项结论）</a></h2>
<ol>
<li>正确性结论：</li>
<li>一致性结论：</li>
<li>计费结论：</li>
<li>侧信道结论：</li>
<li>可维护性结论：</li>
</ol>
<h2 id="f11-发布门禁"><a class="header" href="#f11-发布门禁">F.11 发布门禁</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 通过语义门禁（正确 + 一致）</li>
<li><input disabled="" type="checkbox"> 通过经济门禁（计费 + DoS）</li>
<li><input disabled="" type="checkbox"> 通过安全门禁（侧信道 + 边界）</li>
<li><input disabled="" type="checkbox"> 通过回滚门禁（可撤回 + 可恢复）</li>
</ul>
<p>发布建议：</p>
<ul>
<li><input disabled="" type="checkbox"> 可发布</li>
<li><input disabled="" type="checkbox"> 有条件发布（需补充）</li>
<li><input disabled="" type="checkbox"> 拒绝发布</li>
</ul>
<h2 id="f12-审计签署"><a class="header" href="#f12-审计签署">F.12 审计签署</a></h2>
<ul>
<li>负责人签名：</li>
<li>审计人签名：</li>
<li>日期：</li>
</ul>
<h2 id="f13-一针见血结论"><a class="header" href="#f13-一针见血结论">F.13 一针见血结论</a></h2>
<p>密码学 PR 的“通过标准”不是跑得快，而是：语义不漂移、计费不失真、安全边界不退化。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-h-端到端案例secp256k1-验签在-ckb-vm-中的执行解剖"><a class="header" href="#附录-h-端到端案例secp256k1-验签在-ckb-vm-中的执行解剖">附录 H 端到端案例：secp256k1 验签在 ckb-vm 中的执行解剖</a></h1>
<h2 id="h1-目的"><a class="header" href="#h1-目的">H.1 目的</a></h2>
<p>本附录给出“从输入到退出码”的一条完整案例线：</p>
<ul>
<li>输入：包含签名与消息摘要的验证请求</li>
<li>过程：ELF 装载 -&gt; 指令执行 -&gt; 密码学热点路径</li>
<li>输出：返回成功/失败码与可计费成本</li>
</ul>
<p>目标不是讲数学细节，而是把“工程执行路径”讲透。</p>
<h2 id="h2-场景设定"><a class="header" href="#h2-场景设定">H.2 场景设定</a></h2>
<p>假设合约完成一次标准验签，流程可抽象为：</p>
<ol>
<li>从参数读取签名、公钥、消息摘要</li>
<li>执行曲线点运算与标量运算</li>
<li>比较校验结果</li>
<li>通过 <code>ecall</code> 退出并返回状态</li>
</ol>
<h2 id="h3-运行阶段分解"><a class="header" href="#h3-运行阶段分解">H.3 运行阶段分解</a></h2>
<h3 id="h31-装载阶段"><a class="header" href="#h31-装载阶段">H.3.1 装载阶段</a></h3>
<ul>
<li><code>parse_elf</code> 提取段信息和入口</li>
<li><code>load_binary_inner</code> 按 action 写页与权限</li>
<li><code>initialize_stack</code> 写入参数和 ABI 布局</li>
</ul>
<h3 id="h32-执行阶段"><a class="header" href="#h32-执行阶段">H.3.2 执行阶段</a></h3>
<p>主循环反复执行：</p>
<ul>
<li>decode（含缓存与可能的 MOP 融合）</li>
<li>cycles 累加</li>
<li>execute（可能走 trace/threaded path）</li>
</ul>
<h3 id="h33-退出阶段"><a class="header" href="#h33-退出阶段">H.3.3 退出阶段</a></h3>
<ul>
<li>验签成功或失败写入 <code>a0</code></li>
<li><code>A7=93</code> 调用 <code>ecall</code> 退出</li>
<li><code>exit_code</code> 返回给宿主</li>
</ul>
<h2 id="h4-热点路径画像工程视角"><a class="header" href="#h4-热点路径画像工程视角">H.4 热点路径画像（工程视角）</a></h2>
<p>在典型实现中，热点会集中在：</p>
<ul>
<li>大整数乘法/约简链</li>
<li>位操作与条件选择</li>
<li>少量内存加载与状态搬运</li>
</ul>
<p>这解释了为何以下机制重要：</p>
<ul>
<li>M/MOP：降低大整数链开销</li>
<li>B 扩展：降低位操作拼装开销</li>
<li>Trace：降低循环体解释器噪声</li>
</ul>
<h2 id="h5-成本剖析模板"><a class="header" href="#h5-成本剖析模板">H.5 成本剖析模板</a></h2>
<p>建议记录以下指标：</p>
<ul>
<li><code>total_cycles</code></li>
<li><code>top_opcodes</code></li>
<li><code>mop_hit_ratio</code></li>
<li><code>trace_hit_ratio</code></li>
<li><code>syscall_count</code></li>
</ul>
<p>结合输入规模变化（批量验签 N）观测曲线形态，才能判断优化是否真实有效。</p>
<h2 id="h6-风险点清单"><a class="header" href="#h6-风险点清单">H.6 风险点清单</a></h2>
<ol>
<li>跨后端语义漂移：Rust/ASM 路径结果不一致</li>
<li>计费偏差：热点路径被低估导致 DoS 面</li>
<li>侧信道风险：数据相关分支或访存模式</li>
<li>版本兼容风险：语义修复影响旧合约</li>
</ol>
<h2 id="h7-审计流程示例"><a class="header" href="#h7-审计流程示例">H.7 审计流程示例</a></h2>
<ul>
<li>第一步：固定测试向量，跑 Rust 与 ASM 双后端</li>
<li>第二步：比较寄存器摘要与内存摘要</li>
<li>第三步：比较 cycles 与错误码一致性</li>
<li>第四步：对热点函数做恒时风险检查</li>
</ul>
<h2 id="h8-与主文的映射关系"><a class="header" href="#h8-与主文的映射关系">H.8 与主文的映射关系</a></h2>
<ul>
<li>执行主线：第 2、4 章</li>
<li>权限与装载：第 3 章</li>
<li>密码学指令映射：第 10 章</li>
<li>风险与治理：第 11 章</li>
</ul>
<h2 id="h9-一针见血结论"><a class="header" href="#h9-一针见血结论">H.9 一针见血结论</a></h2>
<p>端到端案例的价值在于把“抽象架构论点”落成“可复现实验事实”；没有案例，优化与安全都容易停留在口号层。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-i-端到端案例哈希与-merkle-验证执行解剖"><a class="header" href="#附录-i-端到端案例哈希与-merkle-验证执行解剖">附录 I 端到端案例：哈希与 Merkle 验证执行解剖</a></h1>
<h2 id="i1-目的"><a class="header" href="#i1-目的">I.1 目的</a></h2>
<p>本附录聚焦“哈希 + Merkle”这类链上常见验证路径，给出工程化执行解剖。</p>
<h2 id="i2-场景设定"><a class="header" href="#i2-场景设定">I.2 场景设定</a></h2>
<p>典型交易验证会包含：</p>
<ol>
<li>对输入片段做哈希轮函数计算</li>
<li>按路径节点迭代做 Merkle 根重建</li>
<li>对比目标根并返回验证结果</li>
</ol>
<h2 id="i3-指令级特征"><a class="header" href="#i3-指令级特征">I.3 指令级特征</a></h2>
<p>相比 secp，哈希/Merkle 路径更偏向：</p>
<ul>
<li>位操作密集（rotate/xor/shift）</li>
<li>小块数据搬运频繁</li>
<li>循环体结构稳定</li>
</ul>
<p>因此 B 扩展与 Trace 机制对这类路径通常更敏感。</p>
<h2 id="i4-成本行为特点"><a class="header" href="#i4-成本行为特点">I.4 成本行为特点</a></h2>
<p>常见成本画像：</p>
<ul>
<li>opcode 类型集中，长尾较短</li>
<li>syscall 比重通常低，算术与访存占主导</li>
<li>cycles 对输入长度近似线性，但受内存布局影响</li>
</ul>
<h2 id="i5-关键优化点"><a class="header" href="#i5-关键优化点">I.5 关键优化点</a></h2>
<ol>
<li>减少无谓拷贝：优先优化数据布局</li>
<li>提升循环命中：稳定 basic block 结构</li>
<li>控制边界检查开销：避免重复无效检查</li>
</ol>
<h2 id="i6-风险点"><a class="header" href="#i6-风险点">I.6 风险点</a></h2>
<ul>
<li>计费模型低估小块高频路径</li>
<li>汇编快路径与解释路径在边界轮次不一致</li>
<li>大输入时栈/内存边界处理错误</li>
</ul>
<h2 id="i7-实验建议"><a class="header" href="#i7-实验建议">I.7 实验建议</a></h2>
<ul>
<li>输入规模从小到大做分层采样</li>
<li>对比不同后端的 cycles 曲线</li>
<li>抽样检查 trace 命中率与 cache 退化点</li>
</ul>
<h2 id="i8-与主文映射"><a class="header" href="#i8-与主文映射">I.8 与主文映射</a></h2>
<ul>
<li>解码与 trace：第 4 章</li>
<li>密码学与扩展：第 10 章</li>
<li>计费与治理：第 11 章</li>
</ul>
<h2 id="i9-一针见血结论"><a class="header" href="#i9-一针见血结论">I.9 一针见血结论</a></h2>
<p>哈希/Merkle 路径优化的核心不是“更快指令”，而是“更稳定的数据与控制流结构”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-c-risc-v-专题isa-选择操作系统语义与落地策略"><a class="header" href="#附录-c-risc-v-专题isa-选择操作系统语义与落地策略">附录 C RISC-V 专题：ISA 选择、操作系统语义与落地策略</a></h1>
<h2 id="c1-目标"><a class="header" href="#c1-目标">C.1 目标</a></h2>
<p>本附录聚焦 RISC-V 在区块链 VM 中的“工程可治理性”，不是做教科书式 ISA 介绍。</p>
<p>核心问题：</p>
<ol>
<li>为什么 RISC-V 特别适合共识执行层？</li>
<li><code>ckb-vm</code> 目前采用的 ISA 组合意味着什么？</li>
<li>后续扩展（如 V）应如何分阶段引入？</li>
</ol>
<h2 id="c2-图-c-1从-isa-到协议治理的影响链"><a class="header" href="#c2-图-c-1从-isa-到协议治理的影响链">C.2 图 C-1：从 ISA 到协议治理的影响链</a></h2>
<pre><code class="language-text">ISA semantics
  -&gt; decoder/loader complexity
  -&gt; multi-backend consistency
  -&gt; tooling &amp; audit cost
  -&gt; protocol upgrade governance
</code></pre>
<h2 id="c3-ckb-vm-的-isa-画像"><a class="header" href="#c3-ckb-vm-的-isa-画像">C.3 <code>ckb-vm</code> 的 ISA 画像</a></h2>
<p>从 <code>src/lib.rs</code> 与 <code>src/machine/mod.rs</code> 可见，当前常用组合是：</p>
<ul>
<li><code>IMC</code>：基础执行与压缩指令</li>
<li><code>B</code>：位操作扩展</li>
<li><code>A</code>：原子语义</li>
<li><code>MOP</code>：宏操作融合（实现层扩展）</li>
</ul>
<p>这套组合体现出明确价值取向：</p>
<ul>
<li>既要支持密码学高频路径</li>
<li>又要保持解释执行和审计可控</li>
</ul>
<h2 id="c4-指令编码规整性与解码收益"><a class="header" href="#c4-指令编码规整性与解码收益">C.4 指令编码规整性与解码收益</a></h2>
<p><code>src/decoder.rs</code> 利用 RISC-V 编码规律处理：</p>
<ul>
<li>RVC/32 位指令判别</li>
<li>页尾跨界取指</li>
<li>decode cache 与 MOP 识别</li>
</ul>
<p>规整编码的实际收益是：</p>
<ul>
<li>解码逻辑可维护</li>
<li>优化点可定位</li>
<li>边界行为可测试</li>
</ul>
<h2 id="c5-操作系统语义映射"><a class="header" href="#c5-操作系统语义映射">C.5 操作系统语义映射</a></h2>
<p>RISC-V 在 <code>ckb-vm</code> 中不是“CPU 仿真”，而是“OS 风格执行语义承载”：</p>
<ul>
<li><code>ecall/ebreak</code> -&gt; 陷入机制</li>
<li>页权限 -&gt; W^X 与 freeze</li>
<li>栈 ABI -&gt; 对齐与参数布局</li>
<li>错误码 -&gt; 可重放失败路径</li>
</ul>
<p>这也是为什么本书把 VM 视为“微型操作系统内核”。</p>
<h2 id="c6-版本兼容策略与语义治理"><a class="header" href="#c6-版本兼容策略与语义治理">C.6 版本兼容策略与语义治理</a></h2>
<p><code>VERSION0/1/2</code> 的存在说明一个现实：</p>
<ul>
<li>执行层 bug 修复必须与历史语义兼容并存。</li>
<li>协议升级不能用“覆盖式修复”，而是要版本门控。</li>
</ul>
<p>这是一种“协议级软件工程”：正确不是单版本正确，而是历史全域可重放正确。</p>
<h2 id="c7-反例分析isa-扩展无治理引入"><a class="header" href="#c7-反例分析isa-扩展无治理引入">C.7 反例分析：ISA 扩展无治理引入</a></h2>
<p>反例场景：直接启用新扩展，不做版本隔离与计费校准：</p>
<ul>
<li>同一合约在不同节点配置下表现不一致。</li>
<li>费用曲线突变，出现经济套利与 DoS 窗口。</li>
</ul>
<p>教训：任何新扩展都必须先过“语义一致 + 计费一致 + 工具链可复现”三重门禁。</p>
<h2 id="c8-向量扩展v引入路线建议"><a class="header" href="#c8-向量扩展v引入路线建议">C.8 向量扩展（V）引入路线建议</a></h2>
<h3 id="c81-分阶段路线"><a class="header" href="#c81-分阶段路线">C.8.1 分阶段路线</a></h3>
<ol>
<li>规范阶段：明确子集、禁用项、边界语义。</li>
<li>实现阶段：先 Rust 语义后端，再逐步引入 ASM 快路径。</li>
<li>计费阶段：建立向量指令专属成本模型。</li>
<li>发布阶段：灰度、对拍、回滚预案。</li>
</ol>
<h3 id="c82-不建议的路线"><a class="header" href="#c82-不建议的路线">C.8.2 不建议的路线</a></h3>
<ul>
<li>先上快路径再补语义文档</li>
<li>只做 microbenchmark 不做真实负载</li>
<li>缺乏跨后端一致性测试就推进协议升级</li>
</ul>
<h2 id="c9-risc-v-审计清单出版版"><a class="header" href="#c9-risc-v-审计清单出版版">C.9 RISC-V 审计清单（出版版）</a></h2>
<ul>
<li><input disabled="" type="checkbox"> ISA 子集是否有明确规范与版本边界。</li>
<li><input disabled="" type="checkbox"> 新扩展是否附带可执行测试向量与反例集。</li>
<li><input disabled="" type="checkbox"> 解码器、执行器、计费器是否同步演进。</li>
<li><input disabled="" type="checkbox"> Rust/ASM 是否完成跨平台差分回归。</li>
<li><input disabled="" type="checkbox"> 工具链版本是否可复现、可追踪。</li>
</ul>
<h2 id="c10-工程模板扩展提案最小包"><a class="header" href="#c10-工程模板扩展提案最小包">C.10 工程模板：扩展提案最小包</a></h2>
<p>一个可上线的扩展提案，至少应包含：</p>
<ol>
<li>语义说明（含边界条件）</li>
<li>解码与执行实现</li>
<li>计费模型与校准报告</li>
<li>跨后端一致性报告</li>
<li>回滚方案与兼容性声明</li>
</ol>
<h2 id="c11-一针见血结论"><a class="header" href="#c11-一针见血结论">C.11 一针见血结论</a></h2>
<p>RISC-V 在区块链 VM 的真正价值，不是“开放”这一个标签，而是它能把 ISA、执行器和协议治理连接成一条可长期维护的工程链。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-b-术语总表带锚点"><a class="header" href="#附录-b-术语总表带锚点">附录 B 术语总表（带锚点）</a></h1>
<blockquote>
<p>说明：本附录为术语定义入口；跨章节映射见附录 D。</p>
</blockquote>
<p><a id="term-a-extension"></a></p>
<h3 id="a-extension"><a class="header" href="#a-extension">A Extension</a></h3>
<p>RISC-V 原子指令扩展，包含 <code>LR/SC/AMO</code>。</p>
<p><a id="term-b-extension"></a></p>
<h3 id="b-extension"><a class="header" href="#b-extension">B Extension</a></h3>
<p>RISC-V 位操作扩展，覆盖旋转、位计数、无进位乘法等。</p>
<p><a id="term-coremachine"></a></p>
<h3 id="coremachine"><a class="header" href="#coremachine">CoreMachine</a></h3>
<p><code>ckb-vm</code> 中只描述寄存器/PC/内存等核心状态的抽象接口。</p>
<p><a id="term-consensus-safety"></a></p>
<h3 id="consensus-safety"><a class="header" href="#consensus-safety">Consensus Safety</a></h3>
<p>同一交易在所有诚实节点上产出一致状态结果，不出现语义分叉。</p>
<p><a id="term-cycle"></a></p>
<h3 id="cycle"><a class="header" href="#cycle">Cycle</a></h3>
<p>VM 的执行计费单位，用于资源预算控制。</p>
<p><a id="term-cycle-budget"></a></p>
<h3 id="cycle-budget"><a class="header" href="#cycle-budget">Cycle Budget</a></h3>
<p>一次执行可用的最大 cycle 上限，超限应返回确定错误。</p>
<p><a id="term-datasource"></a></p>
<h3 id="datasource"><a class="header" href="#datasource">DataSource</a></h3>
<p><code>snapshot2</code> 中可复用稳定数据源抽象，用于减少快照体积。</p>
<p><a id="term-defaultmachine"></a></p>
<h3 id="defaultmachine"><a class="header" href="#defaultmachine">DefaultMachine</a></h3>
<p><code>ckb-vm</code> 核心机器实现，组合 inner machine、syscalls、debugger 与计费。</p>
<p><a id="term-determinism"></a></p>
<h3 id="determinism"><a class="header" href="#determinism">Determinism</a></h3>
<p>同输入同输出同错误语义。</p>
<p><a id="term-differential-testing"></a></p>
<h3 id="differential-testing"><a class="header" href="#differential-testing">Differential Testing</a></h3>
<p>通过多后端/多平台对拍验证执行一致性的测试方法。</p>
<p><a id="term-dirty-page"></a></p>
<h3 id="dirty-page"><a class="header" href="#dirty-page">Dirty Page</a></h3>
<p>执行期间发生写入的内存页。</p>
<p><a id="term-ecall"></a></p>
<h3 id="ecall"><a class="header" href="#ecall">Ecall</a></h3>
<p>RISC-V 系统调用陷入指令。</p>
<p><a id="term-elf"></a></p>
<h3 id="elf"><a class="header" href="#elf">ELF</a></h3>
<p>Executable and Linkable Format，可执行文件格式。</p>
<p><a id="term-execution-governance"></a></p>
<h3 id="execution-governance"><a class="header" href="#execution-governance">Execution Governance</a></h3>
<p>执行层升级、兼容、回滚与发布门禁的治理体系。</p>
<p><a id="term-fast-path"></a></p>
<h3 id="fast-path"><a class="header" href="#fast-path">Fast Path</a></h3>
<p>高频执行路径，通常为性能优化重点。</p>
<p><a id="term-gas-fairness"></a></p>
<h3 id="gas-fairness"><a class="header" href="#gas-fairness">Gas Fairness</a></h3>
<p>计费与实际资源消耗之间的一致性。</p>
<p><a id="term-governance-cost"></a></p>
<h3 id="governance-cost"><a class="header" href="#governance-cost">Governance Cost</a></h3>
<p>协议在长期维护、升级与审计中需要支付的综合成本。</p>
<p><a id="term-imc"></a></p>
<h3 id="imc"><a class="header" href="#imc">IMC</a></h3>
<p>RISC-V 基础整数指令集与压缩指令组合。</p>
<p><a id="term-m-extension"></a></p>
<h3 id="m-extension"><a class="header" href="#m-extension">M Extension</a></h3>
<p>RISC-V 乘除扩展。</p>
<p><a id="term-mop"></a></p>
<h3 id="mop"><a class="header" href="#mop">MOP</a></h3>
<p>Macro-Operation Fusion，宏操作融合。</p>
<p><a id="term-open-isa"></a></p>
<h3 id="open-isa"><a class="header" href="#open-isa">Open ISA</a></h3>
<p>规范公开、可实现、可审计的指令集架构。</p>
<p><a id="term-pause"></a></p>
<h3 id="pause"><a class="header" href="#pause">Pause</a></h3>
<p><code>ckb-vm</code> 中断控制信号机制，可用于安全暂停执行。</p>
<p><a id="term-program-metadata"></a></p>
<h3 id="programmetadata"><a class="header" href="#programmetadata">ProgramMetadata</a></h3>
<p>ELF 解析后生成的装载动作集合。</p>
<p><a id="term-runner"></a></p>
<h3 id="runner"><a class="header" href="#runner">Runner</a></h3>
<p>驱动 VM 生命周期（加载、执行、退出）的调度器抽象。</p>
<p><a id="term-rvc"></a></p>
<h3 id="rvc"><a class="header" href="#rvc">RVC</a></h3>
<p>RISC-V Compressed Instructions，16 位压缩指令。</p>
<p><a id="term-semantic-drift"></a></p>
<h3 id="semantic-drift"><a class="header" href="#semantic-drift">Semantic Drift</a></h3>
<p>实现随时间偏离既定语义规范。</p>
<p><a id="term-slow-path"></a></p>
<h3 id="slow-path"><a class="header" href="#slow-path">Slow Path</a></h3>
<p>低频或复杂路径，通常在快路径无法覆盖时触发。</p>
<p><a id="term-snapshot"></a></p>
<h3 id="snapshot"><a class="header" href="#snapshot">Snapshot</a></h3>
<p>用于挂起/恢复 VM 的状态序列化结构。</p>
<p><a id="term-supportmachine"></a></p>
<h3 id="supportmachine"><a class="header" href="#supportmachine">SupportMachine</a></h3>
<p>在 <code>CoreMachine</code> 基础上扩展 cycles/load/reset 等能力的接口。</p>
<p><a id="term-syscalls-trait"></a></p>
<h3 id="syscalls-trait"><a class="header" href="#syscalls-trait">Syscalls Trait</a></h3>
<p>宿主能力注入接口，定义 <code>initialize</code> 与 <code>ecall</code>。</p>
<p><a id="term-tcb"></a></p>
<h3 id="tcb"><a class="header" href="#tcb">TCB</a></h3>
<p>Trusted Computing Base，可信计算基。</p>
<p><a id="term-trace"></a></p>
<h3 id="trace"><a class="header" href="#trace">Trace</a></h3>
<p>按基本块缓存的指令与执行线程集合。</p>
<p><a id="term-v-extension"></a></p>
<h3 id="v-extension"><a class="header" href="#v-extension">V Extension</a></h3>
<p>RISC-V 向量扩展。</p>
<p><a id="term-wxorx"></a></p>
<h3 id="wx"><a class="header" href="#wx">W^X</a></h3>
<p>Write xor Execute，页不可同时写与执行。</p>
<p><a id="term-wxorxmemory"></a></p>
<h3 id="wxorxmemory"><a class="header" href="#wxorxmemory">WXorXMemory</a></h3>
<p><code>ckb-vm</code> 的权限包装内存，实现 W^X 检查。</p>
<p><a id="term-zero-register"></a></p>
<h3 id="zero-register"><a class="header" href="#zero-register">Zero Register</a></h3>
<p>RISC-V <code>x0</code> 寄存器，读恒为 0，写入被忽略。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-d-术语索引交叉章节-x-代码-x-定义"><a class="header" href="#附录-d-术语索引交叉章节-x-代码-x-定义">附录 D 术语索引交叉（章节 x 代码 x 定义）</a></h1>
<blockquote>
<p>使用方式：先在本附录定位术语，再跳到附录 B 对应定义，再回到章节中的应用语境。</p>
</blockquote>
<div class="table-wrapper">
<table>
<thead>
<tr><th>术语</th><th>主要章节</th><th>代码锚点</th><th>定义入口</th></tr>
</thead>
<tbody>
<tr><td>Determinism</td><td>第 1, 5, 7, 11 章</td><td><code>src/machine/mod.rs</code>, <code>src/error.rs</code></td><td>附录 B <code>Determinism</code></td></tr>
<tr><td>Cycle Budget</td><td>第 1, 11 章</td><td><code>SupportMachine::add_cycles</code></td><td>附录 B <code>Cycle Budget</code></td></tr>
<tr><td>CoreMachine</td><td>第 2 章</td><td><code>src/machine/mod.rs</code> trait 定义</td><td>附录 B <code>CoreMachine</code></td></tr>
<tr><td>SupportMachine</td><td>第 2 章</td><td><code>src/machine/mod.rs</code> trait 定义</td><td>附录 B <code>SupportMachine</code></td></tr>
<tr><td>Runner</td><td>第 2 章</td><td><code>DefaultMachineRunner</code></td><td>附录 B <code>Runner</code></td></tr>
<tr><td>ELF</td><td>第 3 章</td><td><code>src/elf.rs</code></td><td>附录 B <code>ELF</code></td></tr>
<tr><td>ProgramMetadata</td><td>第 3, 6 章</td><td><code>ProgramMetadata</code>, <code>LoadingAction</code></td><td>附录 B <code>ProgramMetadata</code></td></tr>
<tr><td>W^X</td><td>第 3, 11 章</td><td><code>src/memory/wxorx.rs</code></td><td>附录 B <code>W^X</code></td></tr>
<tr><td>WXorXMemory</td><td>第 3, 11 章</td><td><code>WXorXMemory</code></td><td>附录 B <code>WXorXMemory</code></td></tr>
<tr><td>RVC</td><td>第 4, 9 章</td><td><code>decode_bits</code></td><td>附录 B <code>RVC</code></td></tr>
<tr><td>MOP</td><td>第 4, 10 章</td><td><code>decode_mop</code>, <code>handle_wide_*</code></td><td>附录 B <code>MOP</code></td></tr>
<tr><td>Trace</td><td>第 4, 10 章</td><td><code>src/machine/trace.rs</code></td><td>附录 B <code>Trace</code></td></tr>
<tr><td>Fast Path</td><td>第 4, 8 章</td><td>ASM 执行快路径</td><td>附录 B <code>Fast Path</code></td></tr>
<tr><td>Slow Path</td><td>第 4, 8 章</td><td><code>RET_SLOWPATH</code> 回退</td><td>附录 B <code>Slow Path</code></td></tr>
<tr><td>Ecall</td><td>第 2, 5 章</td><td><code>Machine::ecall</code></td><td>附录 B <code>Ecall</code></td></tr>
<tr><td>Syscalls Trait</td><td>第 5 章</td><td><code>src/syscalls/mod.rs</code></td><td>附录 B <code>Syscalls Trait</code></td></tr>
<tr><td>TCB</td><td>第 5 章</td><td>syscall 边界设计</td><td>附录 B <code>TCB</code></td></tr>
<tr><td>Snapshot</td><td>第 6 章</td><td><code>snapshot.rs</code>, <code>snapshot2.rs</code></td><td>附录 B <code>Snapshot</code></td></tr>
<tr><td>Dirty Page</td><td>第 6 章</td><td><code>FLAG_DIRTY</code></td><td>附录 B <code>Dirty Page</code></td></tr>
<tr><td>DataSource</td><td>第 6 章</td><td><code>Snapshot2Context::store_bytes</code></td><td>附录 B <code>DataSource</code></td></tr>
<tr><td>Zero Register</td><td>第 7 章</td><td><code>update_register</code></td><td>附录 B <code>Zero Register</code></td></tr>
<tr><td>Semantic Drift</td><td>第 7, 8, 11 章</td><td>多后端同步风险</td><td>附录 B <code>Semantic Drift</code></td></tr>
<tr><td>Differential Testing</td><td>第 8, 11 章</td><td>Rust/ASM 对拍</td><td>附录 B <code>Differential Testing</code></td></tr>
<tr><td>Open ISA</td><td>第 9 章</td><td>ISA 公开规范收益</td><td>附录 B <code>Open ISA</code></td></tr>
<tr><td>Governance Cost</td><td>第 9 章</td><td>工具链/升级长期成本</td><td>附录 B <code>Governance Cost</code></td></tr>
<tr><td>B Extension</td><td>第 10 章</td><td><code>src/instructions/b.rs</code></td><td>附录 B <code>B Extension</code></td></tr>
<tr><td>M Extension</td><td>第 10 章</td><td><code>src/instructions/execute.rs</code></td><td>附录 B <code>M Extension</code></td></tr>
<tr><td>Gas Fairness</td><td>第 10 章</td><td><code>src/cost_model.rs</code></td><td>附录 B <code>Gas Fairness</code></td></tr>
<tr><td>Execution Governance</td><td>第 9, 11 章</td><td>版本策略与发布门禁</td><td>附录 B <code>Execution Governance</code></td></tr>
<tr><td>V Extension</td><td>附录 C</td><td>向量扩展引入路线</td><td>附录 B <code>V Extension</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-e-出版规范图号统一代码引用与章节收口"><a class="header" href="#附录-e-出版规范图号统一代码引用与章节收口">附录 E 出版规范：图号统一、代码引用与章节收口</a></h1>
<h2 id="e1-图号统一规范"><a class="header" href="#e1-图号统一规范">E.1 图号统一规范</a></h2>
<h3 id="e11-命名规则"><a class="header" href="#e11-命名规则">E.1.1 命名规则</a></h3>
<ul>
<li>章内图号采用 <code>图 X-Y</code>，其中：
<ul>
<li><code>X</code> 为章节号（1-11）</li>
<li><code>Y</code> 为章内序号（从 1 开始）</li>
</ul>
</li>
<li>章节标题中图示建议写作：<code>图 X-Y：&lt;图名&gt;</code></li>
</ul>
<h3 id="e12-适用范围"><a class="header" href="#e12-适用范围">E.1.2 适用范围</a></h3>
<ul>
<li>主体章节（第 1~11 章）</li>
<li>专题附录（A/C）建议使用 <code>图 A-Y</code>、<code>图 C-Y</code></li>
</ul>
<h3 id="e13-反例不推荐"><a class="header" href="#e13-反例不推荐">E.1.3 反例（不推荐）</a></h3>
<ul>
<li>使用全书连续编号（如图 27），读者难以定位章节上下文。</li>
<li>同章混用“图 3-1”和“Figure 1”，破坏检索一致性。</li>
</ul>
<h2 id="e2-代码引用规范"><a class="header" href="#e2-代码引用规范">E.2 代码引用规范</a></h2>
<ul>
<li>统一使用反引号包裹路径与符号：<code>src/machine/mod.rs</code>。</li>
<li>章节末必须提供“参考实现清单（代码锚点）”。</li>
<li>章节叙事中出现关键语义时，应至少给出一个可定位代码锚点。</li>
</ul>
<h2 id="e3-章节收口规范"><a class="header" href="#e3-章节收口规范">E.3 章节收口规范</a></h2>
<p>每章应按以下顺序收口：</p>
<ol>
<li><code>一针见血结论</code></li>
<li><code>反例分析</code></li>
<li><code>架构评审清单（出版版）</code></li>
<li><code>参考实现清单（代码锚点）</code></li>
<li><code>术语索引交叉</code></li>
<li><code>审稿人问题清单（出版评审）</code></li>
</ol>
<h2 id="e4-页面包装规范mdbook"><a class="header" href="#e4-页面包装规范mdbook">E.4 页面包装规范（mdBook）</a></h2>
<ul>
<li>每章 wrapper 需包含统一页眉：章节号、文档版本、评审状态。</li>
<li>每章 wrapper 需包含统一页脚：章末核查提示（反例/清单/锚点/术语/审稿问题）。</li>
<li>wrapper 仅做展示层补充，不应覆盖主体章节语义内容。</li>
</ul>
<h2 id="e5-当前合规性检查本稿"><a class="header" href="#e5-当前合规性检查本稿">E.5 当前合规性检查（本稿）</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>章节</th><th>图号规范</th><th>反例分析</th><th>评审清单</th><th>参考实现清单</th><th>术语交叉</th><th>审稿问题</th></tr>
</thead>
<tbody>
<tr><td>第 1 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 2 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 3 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 4 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 5 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 6 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 7 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 8 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 9 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 10 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
<tr><td>第 11 章</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td><td>通过</td></tr>
</tbody>
</table>
</div>
<h2 id="e6-一针见血结论"><a class="header" href="#e6-一针见血结论">E.6 一针见血结论</a></h2>
<p>统一的图号、代码锚点与章节收口规范，本质上是“可审计写作”的基础设施。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="附录-g-作者改稿检查清单终版"><a class="header" href="#附录-g-作者改稿检查清单终版">附录 G 作者改稿检查清单（终版）</a></h1>
<blockquote>
<p>用途：在交付“终版出版稿”前，逐项确认文本一致性、证据完整性、发布可维护性。</p>
</blockquote>
<h2 id="g1-结构一致性"><a class="header" href="#g1-结构一致性">G.1 结构一致性</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 第 1-11 章均包含：结论、反例、评审清单、代码锚点、术语交叉、审稿问题。</li>
<li><input disabled="" type="checkbox"> 章节编号连续，图号统一为 <code>图 X-Y</code>。</li>
<li><input disabled="" type="checkbox"> 章节标题与 <code>mdbook/src/SUMMARY.md</code> 完全一致。</li>
<li><input disabled="" type="checkbox"> 附录 A/B/C/D/E/F/G 均在目录中可访问。</li>
</ul>
<h2 id="g2-证据一致性"><a class="header" href="#g2-证据一致性">G.2 证据一致性</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 每章核心观点至少绑定一个源码锚点。</li>
<li><input disabled="" type="checkbox"> 代码路径引用无拼写错误（如 <code>src/machine/mod.rs</code>）。</li>
<li><input disabled="" type="checkbox"> 术语定义与章节用法无冲突（通过附录 D 抽查）。</li>
<li><input disabled="" type="checkbox"> 结论未超出代码证据支持范围。</li>
</ul>
<h2 id="g3-安全与治理叙事"><a class="header" href="#g3-安全与治理叙事">G.3 安全与治理叙事</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 明确区分确定性、计费、公平性、恒时安全四条线。</li>
<li><input disabled="" type="checkbox"> 明确披露 Rust/ASM 双后端一致性风险。</li>
<li><input disabled="" type="checkbox"> 明确披露 cycles 模型“估算属性”与校准需求。</li>
<li><input disabled="" type="checkbox"> RISC-V 扩展引入建议包含版本门禁与回滚预案。</li>
</ul>
<h2 id="g4-密码学专题质量门禁"><a class="header" href="#g4-密码学专题质量门禁">G.4 密码学专题质量门禁</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 附录 A 覆盖 secp/hash/Merkle 三类负载。</li>
<li><input disabled="" type="checkbox"> 附录 F 可直接用于 PR 审计，不依赖额外解释。</li>
<li><input disabled="" type="checkbox"> 文中对侧信道风险的表述无“自动安全”误导。</li>
<li><input disabled="" type="checkbox"> 计费校准流程可执行、可复核。</li>
</ul>
<h2 id="g5-发布与维护"><a class="header" href="#g5-发布与维护">G.5 发布与维护</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 版本页已更新版本号和日期。</li>
<li><input disabled="" type="checkbox"> 更新日志已记录本轮改动摘要。</li>
<li><input disabled="" type="checkbox"> 审稿人摘要页已同步当前评审重点。</li>
<li><input disabled="" type="checkbox"> 顶层 README 与 manuscript/README 同步。</li>
</ul>
<h2 id="g6-最终签署"><a class="header" href="#g6-最终签署">G.6 最终签署</a></h2>
<ul>
<li><input disabled="" type="checkbox"> 我确认本文档可进入外部评审阶段。</li>
<li><input disabled="" type="checkbox"> 我确认本轮改动未引入结构性断链。</li>
</ul>
<p>作者：<br>日期：</p>
<h2 id="g7-一针见血结论"><a class="header" href="#g7-一针见血结论">G.7 一针见血结论</a></h2>
<p>“终版”不是把文字写满，而是把证据链、风险链、维护链全部闭合。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
