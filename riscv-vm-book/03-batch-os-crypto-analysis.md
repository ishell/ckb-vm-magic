# 批次三：操作系统视角与密码学现实（第 5、6、11 章扩展稿）

## 第 5 章 Syscall、Trap 与宿主能力边界

### 5.1 `ecall` 机制：能力最小化的入口

`Machine::ecall`（`src/machine/mod.rs`）的默认行为非常克制：

- `A7 == 93`：退出并写入 exit code；
- 其他编号：交给注册的 `Syscalls` 模块链式处理；
- 无模块处理则报 `InvalidEcall`。

这意味着 VM 内核默认不信任任何“隐式系统能力”，所有宿主行为必须显式注入。

### 5.2 操作系统类比

它非常像微内核：

- 内核只保留最小 trap 语义；
- 扩展能力通过外部模块提供；
- 模块失败时内核返回确定错误，而非未定义副作用。

在区块链场景，这种模式可以有效控制 Trusted Computing Base。

### 5.3 一针见血结论

把 syscall 做小，不是功能缺失，而是为了把共识攻击面收缩到可审计边界内。

---

## 第 6 章 快照与恢复：把执行状态从“过程”变成“对象”

### 6.1 Snapshot v1：脏页快照

`src/snapshot.rs` 采用经典 dirty-page 方案：

- 保存寄存器、PC、LR 保留地址；
- 遍历内存页，只存 `FLAG_DIRTY` 页内容。

优点是实现简洁，缺点是对“可复用静态数据”复用不足。

### 6.2 Snapshot2：引入 DataSource 的去重快照

`src/snapshot2.rs` 在此基础上更进一步：

- 把稳定数据（如程序段、外部数据源）抽象成 `DataSource`；
- 快照里只保存 `pages_from_source` 的引用信息（id+offset+length）；
- 对真正修改的页仍保存 dirty 内容。

这是一种“内容寻址思维”进入 VM 快照层的设计：

- 减少序列化体积；
- 降低跨轮次执行恢复成本；
- 保持恢复过程确定可重放。

### 6.3 操作系统意义

这相当于把 VM 进程状态切成两类：

- 不变基底（代码/只读数据）；
- 可变增量（脏页、寄存器）。

也是现代容器/虚拟化快照中常见的分层思想。

### 6.4 一针见血结论

快照不是“暂停按钮”，而是链上长任务分段执行的经济学工具。

---

## 第 11 章 架构评估：优势、代价与未来路线

### 11.1 架构优势（硬结论）

1. 语义边界清楚：ELF 装载、页权限、syscall、cycles 都有明确模块归属。
2. 兼容策略成熟：`VERSION0/1/2` 分支保留历史行为，避免链上语义突变。
3. 优化路径克制：trace + MOP + ASM 快路径都在可解释范围内，不越过确定性红线。
4. 内存模型安全：`WXorXMemory` 把“可写/可执行互斥”变成运行期强检查。

### 11.2 主要代价（真实问题）

1. 双引擎一致性成本高：Rust 与 ASM 需要长期差分验证。
2. Cycle 模型仍是估算：`estimate_cycles` 与真实硬件/节点执行特征可能存在偏差。
3. syscall 生态扩展难度：最小化边界是优点，但也提高了宿主集成门槛。
4. 密码学侧信道问题：当前模型主要保证功能确定，不自动保证恒时执行。

### 11.3 一针见血分析：最容易被误解的三件事

### 误解 1："有汇编就不安全"

真正问题不在“是否用汇编”，而在“汇编是否被语义锚点约束”。`ckb-vm` 让 Rust 维护控制流与异常语义，汇编只是快路径执行器，这是一种相对稳健的分工。

### 误解 2："有 RISC-V 就天然快"

RISC-V 是 ISA，不是性能魔法。这里的收益主要来自语义规整与生态开放，性能提升来自 trace/MOP/ASM 的工程实现。

### 误解 3："虚拟机只要能跑合约即可"

在链上，VM 还必须承担计费、公平性与回放验证职责。能跑只是及格线，不是上线标准。

### 11.4 建议路线图（可执行）

1. 建立 Rust/ASM 常态化差分回归：同输入、同版本、同 ISA，比较寄存器与内存快照。
2. 对关键 opcode 引入形式化语义测试集：覆盖除零、溢出、跨页访存、权限边界。
3. 将 cycles 模型与链上真实 workload 数据闭环校准，降低计费失真。
4. 针对密码学高频路径补充恒时实现规范与审计基线（尤其大整数和哈希内核）。
5. 在保持确定性的前提下评估向量扩展引入策略（分阶段、可回滚、可验证）。

### 11.5 最终结论

`ckb-vm` 的成功不在于“做了一个 RISC-V 解释器”，而在于它把区块链执行环境做成了一个小型、可定价、可恢复、可治理的操作系统内核。

Rust 负责把语义变成可维护工程，RISC-V 负责提供稳定且开放的语义地基；两者结合，才是这套架构真正的护城河。

